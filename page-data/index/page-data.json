{"componentChunkName":"component---src-pages-index-jsx","path":"/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"리액트에서 URL 이동시 감지하여 원하는 로직을 넣어보자 🧪 테스트 환경 React v18 AWS SDK for Java1.x 백엔드 : AWS EKS 환경 프론트 : AWS S3 Nginx 환경 배경 기본적으로 업로드 평균 속도는 5MB/s 라고한다. 파일을 Presigned URL에 통째로 올리는 방식으로 개발해두고 50MB 파일이 약 10초 정도 걸…","fields":{"slug":"/posts/springboot/file-upload/"},"frontmatter":{"date":"April 18, 2025","title":"SpringBoot, React, S3 Presigned URL, Multipart File을 이용해 파일 업로드 속도를 개선해보자","tags":["react","springboot"],"emoji":"🚀","series":"SpringBoot"},"rawMarkdownBody":"\r\n# 리액트에서 URL 이동시 감지하여 원하는 로직을 넣어보자\r\n\r\n## 🧪 테스트 환경\r\n\r\n> React v18\r\n>\r\n> AWS SDK for Java1.x\r\n>\r\n> 백엔드 : AWS EKS 환경\r\n>\r\n> 프론트 : AWS S3 Nginx 환경\r\n\r\n## 배경\r\n\r\n기본적으로 업로드 평균 속도는 5MB/s 라고한다.\r\n\r\n파일을 Presigned URL에 통째로 올리는 방식으로 개발해두고 50MB 파일이 약 10초 정도 걸렸었다.\r\n\r\n문제가 생겼다. 고객쪽 네트워크 망이 상태가 안좋은지 업로드 속도가 심각하게 느려졌다.\r\n\r\n네트워크 쪽에서 처리를 해주겠지만, 우선적으로 시스템 내부에서 개선할 내용을 찾아보자.\r\n\r\n## 목표\r\n\r\n1. Presigned URL 속도 체크\r\n2. 4가지 방법 구현 후 속도 비교\r\n   1. Presigned URL을 이용한 파일 업로드\r\n   2. Presigned URL을 이용한 Multipart File 업로드\r\n   3. 서버에 파일 업로드 하여 S3에 업로드\r\n   4. 서버에 Multipart File을 업로드하여 S3에 업로드\r\n3. 네트워크 개선 후 파일 업로드 속도 비교\r\n\r\n## 구현\r\n\r\n### 구현하기 앞서 업로드 속도 체크\r\n\r\n- 브라우저에서 S3 직접 파일 전송\r\n  - 기존 50MB / 10초 => 네트워크 망 상태가 안좋아진 상황 : 50MB / 14분\r\n\r\n### 1. Presigned URL multipart 파일 업로드\r\n\r\n#### React\r\n\r\n동작 방식\r\n\r\n1. 프론트에서 올릴 파일을 자른다.(Multipart로 파일을 자른다.)\r\n2. 프론트에서 올릴 파일 정보를 백엔드로 송신하여 백엔드에서 Presigned URL을 받아온다.\r\n   - 프론트에서 S3로부터 Presigned URL을 받지 않고 백엔드에서 받도록 하였다.\r\n3. Multipart File을 Presigned URL을 이용해 S3에 업로드한다.\r\n4. Multipart File이 모두 업로드되면, S3에서 합칠 수 있도록 백엔드에 요청한다.\r\n\r\n```javascript\r\n// Multipart File로 파일 업로드 로직\r\nexport const FileUploader = forwardRef(props, ref) => {\r\n    const [files, setFiles] = useState<File[]>([]);\r\n\r\n    useImperativeHandle(ref, () => ({\r\n      saveFiles: () => onSaveFiles,\r\n    }))\r\n\r\n    const onSaveFiles = () => {\r\n      // 1. presigned Url multipart 파일 업로드\r\n      await processUploadMultipartFilesWithPresignedUrl(files);\r\n\r\n      ...\r\n    }\r\n\r\n    // 1. presigned Url로 파일을 올리는 로직\r\n    async function processUploadMultipartFilesWithPresignedUrl(files: File[]) {\r\n      // 파일을 얼마 단위로 자를지 설정한다. AWS S3에서는 5MB를 최소 크기로 잡는다.\r\n      const chunkSize = 10 * 1024 * 1024;\r\n      const partCount = Math.ceil(file.size / chunkSize);\r\n\r\n      const uploadPromises = files.map((file) =>\r\n          processUploadMultipartFileWithPresignedUrl(file, chunkSize)\r\n            .then(() => ({ file, status: 'fulfilled' }))\r\n            .catch((error) => ({ file, status: 'rejected', error }))\r\n        );\r\n\r\n      const results = await Promise.allSettled(uploadPromises);\r\n\r\n      const successFiles: File[] = [];\r\n      const failedFiles: File[] = [];\r\n\r\n      results.forEach((result, idx) => {\r\n        const { status, value, reason } = result;\r\n\r\n        if (status === 'fulfilled') {\r\n          const res = value;\r\n          if (res.status === 'fulfilled') {\r\n            successFiles.push(res.file);\r\n          } else {\r\n            console.error(`${res.file.name} 업로드 실패`, res.error);\r\n            failedFiles.push(res.file);\r\n          }\r\n        } else {\r\n          console.error(`${files[idx].name} 업로드 중 알 수 없는 실패`, reason);\r\n          failedFiles.push(files[idx]);\r\n        }\r\n      });\r\n\r\n      console.log(\r\n        '✅ 성공한 파일:',\r\n        successFiles.map((f) => f.name)\r\n      );\r\n      console.log(\r\n        '❌ 실패한 파일:',\r\n        failedFiles.map((f) => f.name)\r\n      );\r\n    }\r\n\r\n    return ...\r\n  }\r\n\r\n  const processUploadMultipartFileWithPresignedUrl = async (\r\n      file: File,\r\n      chunkSize: number\r\n    ) => {\r\n      const partCount = Math.ceil(file.size / chunkSize);\r\n\r\n      try {\r\n        // 1. 프론트에서 올릴 파일 정보를 백엔드로 송신하여 백엔드에서 Presigned URL을 받아온다.\r\n        const FileUploadStartResponse = await axios.get(\"/api/upload/presigned-url/start\", {\r\n          params: {\r\n            fileSize: String(file.size),\r\n            fileName: file.name,\r\n            fileType: file.type,\r\n            partCount: String(partCount),\r\n          },\r\n        })\r\n\r\n        const { uploadId, preSignedUrlList, key } = FileUploadStartResponse;\r\n        // const parts: { partNumber: number; eTag: string }[] = [];\r\n\r\n        // 2. 자른 파일(Multipart File)을 Presigned URL에 올린다.\r\n        const uploadPart = async (i: number) => {\r\n          const start = i * chunkSize;\r\n          const end = Math.min(file.size, start + chunkSize);\r\n          const blob = file.slice(start, end);\r\n\r\n          const res = await axios.put(preSignedUrlList[i], blob, {\r\n            headers: {\r\n              'Content-Type': file.type,\r\n            },\r\n          });\r\n\r\n          /*\r\n              2-1. 파트 업로드시 S3에서 Response Header에 eTag 값을 보내주는데, 가지고 있어야한다.\r\n              이 값을 제대로 받으려면, s3 header cors 설정이 필요하다.\r\n           */\r\n          const eTag = res.headers.etag || res.headers.ETag || res.headers.Etag;\r\n          return { partNumber: i + 1, eTag: eTag.replace(/\"/g, '') };\r\n        };\r\n\r\n        // 3. 병렬 업로드\r\n        const uploadPromises = Array.from({ length: partCount }, (_, i) => uploadPart(i));\r\n        const parts = await Promise.all(uploadPromises);\r\n\r\n        // 4. 완료요청(완료 요청을 해야 part로 올라간 파일들을 S3내에서 합쳐준다)\r\n        await axios.post(\"/api/upload/presigned-url/complete\", {\r\n          uploadId: uploadId,\r\n          key: key,\r\n          parts: parts,\r\n        });\r\n      } catch (error) {\r\n        console.error(`${file.name} 업로드 실패`, error);\r\n      }\r\n    };\r\n```\r\n\r\n#### SpringBoot\r\n\r\n동작방식\r\n\r\n1. /api/upload/presigned-url/start 에서는 파일 정보를 받아 Presigned URL을 만들어 보내준다.\r\n2. /api/upload/presigned-url/complete 에서는 Multipart File을 S3에서 하나의 파일로 합쳐지도록 S3 메서드를 호출한다.\r\n\r\n```java\r\n  @GetMapping(value = \"/api/upload/presigned-url/start\")\r\n  public ResponseEntity<FileUploadStartResponse> startMultipartUpload(\r\n          @RequestParam(\"fileName\") @NotBlank String fileName\r\n          , @RequestParam(\"fileSize\") @NotBlank String fileSize\r\n          , @RequestParam(\"fileType\") @NotBlank String fileType\r\n          , @RequestParam(\"partCount\") @NotBlank int partCount\r\n  ) {\r\n      // AWS SDK\r\n      AmazonS3 s3Client = AmazonS3ClientBuilder.standard()\r\n                    .withRegion(Regions.AP_NORTHEAST_2)\r\n                    .build();\r\n\r\n      // S3에 저장될 키 값(S3 내에서는 파일명으로 봐도 된다.)\r\n      String key = \"upload/\" + UUID.randomUUID() + \"_\" + fileName;\r\n\r\n      ObjectMetadata metadata = new ObjectMetadata();\r\n      metadata.setContentType(fileType);\r\n\r\n      String uploadId = \"\";\r\n      List<String> preSignedUrls = new ArrayList<>();\r\n\r\n      try {\r\n        InitiateMultipartUploadRequest initRequest = new InitiateMultipartUploadRequest([s3 bucket 주소], key)\r\n                .withObjectMetadata(metadata);\r\n\r\n        uploadId = s3Client.initiateMultipartUpload(initRequest).getUploadId();\r\n\r\n        // Pre-Signed URL 만료 시간 (60분 후)\r\n        Date expiration = new Date();\r\n        long expTimeMillis = expiration.getTime();\r\n        // 10분 후 만료\r\n        expTimeMillis += TimeUnit.MINUTES.toMillis(10);\r\n        expiration.setTime(expTimeMillis);\r\n\r\n        // 각 part에 대한 Pre-Signed URL 생성\r\n\r\n        for (int i = 0; i < partCount; i++) {\r\n            GeneratePresignedUrlRequest generatePresignedUrlRequest = new GeneratePresignedUrlRequest([s3 bucket 주소], key)\r\n                    .withMethod(HttpMethod.PUT)\r\n                    .withExpiration(expiration)\r\n                    .withContentType(fileType);\r\n            generatePresignedUrlRequest.addRequestParameter(\"partNumber\", String.valueOf(i + 1));\r\n            generatePresignedUrlRequest.addRequestParameter(\"uploadId\", uploadId);\r\n\r\n            URL url = s3Client.generatePresignedUrl(generatePresignedUrlRequest);\r\n            preSignedUrls.add(url.toString());\r\n        }\r\n\r\n      } catch (Exception e) {\r\n        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\r\n            .body(\"Presigned URL failed for file: \" + fileName + \". Error: \" + e.getMessage());\r\n      }\r\n\r\n      return ResponseEntity.ok(FileUploadStartResponse.builder()\r\n                .uploadId(uploadId)\r\n                .preSignedUrlList(preSignedUrls)\r\n                .key(key)\r\n                .build()\r\n              );\r\n  }\r\n\r\n\r\n  @PostMapping(value = \"/api/upload/presigned-url/complete\")\r\n  public ResponseEntity<String> completeMultipartUpload(\r\n          @RequestBody FileUploadCompleteRequest fileUploadCompleteRequest\r\n          //uploadId, key, parts 세개를 받고있고, parts는 partNumber와 eTag를 받고있습니다.\r\n  ) {\r\n      // AWS SDK\r\n      AmazonS3 s3Client = s3Service.getS3Client();\r\n\r\n      try {\r\n        List<PartETag> partETags = fileUploadCompleteRequest.getParts().stream()\r\n              .map(p -> new PartETag(p.getPartNumber(), p.getETag()))\r\n              .collect(Collectors.toList());\r\n\r\n        CompleteMultipartUploadRequest completeRequest = new CompleteMultipartUploadRequest(\r\n          [s3 bucket 주소],\r\n                fileUploadCompleteRequest.getKey(),\r\n                fileUploadCompleteRequest.getUploadId(),\r\n                partETags\r\n        );\r\n\r\n        s3Client.completeMultipartUpload(completeRequest);\r\n\r\n      } catch  (Exception e) {\r\n        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\r\n            .body(\"Compleye failed\");\r\n      }\r\n\r\n      return new ResponseEntity.ok(\"완료\");\r\n  }\r\n\r\n  @Data\r\n  @Builder\r\n  @NoArgsConstructor\r\n  @AllArgsConstructor\r\n  public class FileUploadCompleteRequest {\r\n          @Schema(description = \"uploadId\", name=\"uploadId\")\r\n          private String uploadId;\r\n\r\n          @Schema(description = \"fileSavePath\", name=\"fileSavePath\")\r\n          private String fileSavePath;\r\n\r\n          @Schema(description = \"parts\", name=\"parts\")\r\n          private List<UploadedPart> parts;\r\n  }\r\n\r\n  @Data\r\n  @Builder\r\n  @NoArgsConstructor\r\n  @AllArgsConstructor\r\n  public class UploadedPart {\r\n          @NotBlank\r\n          @Schema(description = \"partNumber\", name=\"partNumber\")\r\n          private int partNumber;\r\n\r\n          @JsonProperty(\"eTag\")\r\n          @Schema(description = \"eTag\", name=\"eTag\")\r\n          private String eTag;\r\n  }\r\n```\r\n\r\n> 질문\r\n>\r\n> Q1. Presigned URL에서 사용하는 API가 왜 두 개 인가요?\r\n>\r\n> A1. '/api/upload/presigned-url/start' start api에서는 presigned-url을 프론트로 보내는 역할을 하고, '/api/upload/presigned-url/complete' complete api에서는 presigned url에 올린 multipart 파일이 모두 올라간 경우 하나의 파일로 합치는 과정을 진행합니다.\r\n>\r\n> Q2. uploadId, partNumber, etag 얘네들은 뭐죠??\r\n>\r\n> A2. uploadId는 S3에 올린 파일 정보의 고유 번호, partNumber는 S3에 올린 Multipart File의 인덱스번호, eTag는 S3에서 보내준 Multipart File의 고유 번호입니다.\r\n>\r\n> Q3. 프론트에서 eTag가 undefined 오류가 떠요!!!\r\n>\r\n> A3. multipart file을 업로드시 S3쪽에서 response header에 eTag값을 줍니다.\r\n> 이 경우 제대로 받으려면 S3 CORS 설정을 해야합니다. AWS 웹 콘솔에 들어가서 권한 탭을 들어가 CORS를 수정하는 부분이 있는데, 기본적으로 \"AllowedHeaders\": [ \"*\" ], .... 등이 들어가 있을거예요. 이곳에서 편집을 이용해 \"ExposeHeaders\": [\"ETag\"] 내용을 넣어주면 됩니다.\r\n>\r\n> Q4. 백엔드 UploadedPart DTO안에 eTag 위에 있는 JsonProperty 어노테이션은 무엇인가요?\r\n>\r\n> A4. 자바 빈 규칙으로 인해, 두 번 째 글자가 대문자로 오는 경우 제대로 인식하지 못합니다. 그래서 etag로 데이터가 들어온것으로 판단해, 프론트에서 eTag로 데이터를 보낸다해도, 서버에서는 인식하지 못합니다. 그래서 eTag라는 '이름의 데이터다!' 라고 표현하는 어노테이션입니다.\r\n\r\n### 2. 서버에 스트리밍 방식으로 multipartFile 올리는 로직\r\n\r\n#### React\r\n\r\n동작방식\r\n\r\n1. 프론트에서 파일 정보를 보내 백엔드에서 Upload Id를 받아옵니다.\r\n2. 프론트에서 파일을 잘라 Multipart File을 백엔드에 스트리밍 형태로 올립니다.\r\n3. 백엔드에서 받은 Multipart File을 S3에 업로드합니다.\r\n4. S3에 다 올라가면, Multipart File을 합칠 수 있도록 프론트에서 백엔드로 요청합니다.\r\n\r\n```javascript\r\nexport const FileUploader = forwardRef(props, ref) => {\r\n    const [files, setFiles] = useState<File[]>([]);\r\n\r\n    useImperativeHandle(ref, () => ({\r\n      saveFiles: () => onSaveFiles,\r\n    }))\r\n\r\n    const onSaveFiles = () => {\r\n      // 2. 서버에 스트리밍 방식으로 multipartFile 올리는 로직\r\n\r\n      // 각 part마다 크기 설정 AWS S3는 최소 5MB\r\n      const chunkSize = 10 * 1024 * 1024;\r\n\r\n      for (const file of files) {\r\n        await processUploadMultipartFileWithStreaming(file, chunkSize);\r\n      }\r\n\r\n      ...\r\n    }\r\n\r\n    // 2. 서버에 스트리밍 방식으로 multipartFile 올리는 로직\r\n    async function processUploadMultipartFileWithStreaming(file: File, chunkSize: number) {\r\n      // 각 part마다 크기 설정 AWS S3는 최소 5MB\r\n      const partCount = Math.ceil(file.size / chunkSize);\r\n      let uploadedSize = 0;\r\n\r\n      // 1. 서버에 uploadId 요청\r\n      const { uploadId, key } = await axios.get(\"/api/upload/server/start\", {\r\n        params: {\r\n          fileName: file.name,\r\n          fileType: file.type\r\n        },\r\n      });\r\n\r\n      const uploadedParts: { partNumber: number; eTag: string }[] = [];\r\n\r\n      // chunk 파일 업로드 로직\r\n      const uploadChunk = async (i: number) => {\r\n        const start = i * chunkSize;\r\n        const end = Math.min(file.size, start + chunkSize);\r\n        const chunk = file.slice(start, end);\r\n\r\n        const formData = new FormData();\r\n        formData.append('uploadId', uploadId);\r\n        formData.append('key', key);\r\n        formData.append('chunk', blob);\r\n        formData.append('partNumber', String(i + 1));\r\n\r\n        const res = await axios.post(\"/api/upload/server/start\", formData, {\r\n          headers: {\r\n            \"Content-Type\": \"multipart/form-data\", // 생략해도 브라우저가 알아서 넣음\r\n          },\r\n        });\r\n\r\n        uploadedParts[i] = res; // partNumber, eTag\r\n      };\r\n\r\n      await asyncPool(\r\n        10,\r\n        Array.from({ length: partCount }, (_, i) => i),\r\n        uploadChunk\r\n      );\r\n\r\n      // 4. 완료요청\r\n      await await axios.post(\"/api/upload/server/complete\", {\r\n          uploadId: uploadId,\r\n          key: key,\r\n          parts: uploadedParts,\r\n          fileSize: String(file.size)\r\n        }\r\n      );\r\n    }\r\n\r\n    // 브라우저에서 요청하는 api 호출 개수 조절\r\n    async function asyncPool<T, R>(\r\n      poolLimit: number,\r\n      array: T[],\r\n      iteratorFn: (item: T, index: number) => Promise<R>\r\n    ): Promise<R[]> {\r\n      const ret: R[] = [];\r\n      const executing: Promise<any>[] = [];\r\n\r\n      for (let i = 0; i < array.length; i++) {\r\n        const item = array[i];\r\n        const p = Promise.resolve().then(() => iteratorFn(item, i));\r\n\r\n        ret.push(p as any); // 결과 배열에 추가\r\n\r\n        // poolLimit 이하로만 실행\r\n        if (poolLimit <= array.length) {\r\n          const e: Promise<any> = p.then(() => executing.splice(executing.indexOf(e), 1));\r\n          executing.push(e);\r\n          if (executing.length >= poolLimit) {\r\n            await Promise.race(executing); // 제일 먼저 끝난 작업 기다림\r\n          }\r\n        }\r\n      }\r\n\r\n      return Promise.all(ret); // 전체 완료 대기\r\n    }\r\n\r\n    return ...\r\n  }\r\n\r\n\r\n\r\n```\r\n\r\n```java\r\n\r\n  //Upload Id 요청 API\r\n  @GetMapping(value = \"/api/upload/server/start\")\r\n  public ResponseEntity<FileUploadStartResponse> startMultipartUploadWithStreaming(\r\n          @RequestParam(\"fileName\") @NotBlank String fileName\r\n          , @RequestParam(\"fileType\") @NotBlank String fileType\r\n  ) {\r\n      // AWS SDK\r\n      AmazonS3 s3Client = AmazonS3ClientBuilder.standard()\r\n                    .withRegion(Regions.AP_NORTHEAST_2)\r\n                    .build();\r\n\r\n      // S3에 저장될 키 값(S3 내에서는 파일명으로 봐도 된다.)\r\n      String key = \"upload/\" + UUID.randomUUID() + \"_\" + fileName;\r\n\r\n      ObjectMetadata metadata = new ObjectMetadata();\r\n      metadata.setContentType(fileType);\r\n\r\n      String uploadId = \"\";\r\n\r\n      try {\r\n        InitiateMultipartUploadRequest initRequest = new InitiateMultipartUploadRequest([s3 bucket 주소], key)\r\n                .withObjectMetadata(metadata);\r\n\r\n        uploadId = s3Client.initiateMultipartUpload(initRequest).getUploadId();\r\n      } catch (Exception e) {\r\n        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\r\n            .body(\"Presigned URL failed for file: \" + fileName + \". Error: \" + e.getMessage());\r\n      }\r\n\r\n      return ResponseEntity.ok(FileUploadStartResponse.builder()\r\n                .uploadId(uploadId)\r\n                .key(key)\r\n                .build()\r\n              );\r\n  }\r\n\r\n  @Data\r\n  @Builder\r\n  @NoArgsConstructor\r\n  @AllArgsConstructor\r\n  public class UploadedPart {\r\n          @NotBlank\r\n          @Schema(description = \"partNumber\", name=\"partNumber\")\r\n          private int partNumber;\r\n\r\n          @JsonProperty(\"eTag\")\r\n          private String eTag;\r\n  }\r\n\r\n  // Multipart File 업로드 API\r\n  @PostMapping(value = \"/api/upload/server/start\", produces = MediaType.APPLICATION_JSON_VALUE)\r\n    public ResponseEntity<UploadedPart> uploadMultipartFilesWithStreaming(\r\n            @RequestParam(name = \"chunk\") MultipartFile chunk,\r\n            @RequestParam(name = \"key\") String key,\r\n            @RequestParam(name = \"uploadId\") String uploadId,\r\n            @RequestParam(name = \"partNumber\") int partNumber\r\n    ) throws IOException {\r\n\r\n        // AWS SDK\r\n        AmazonS3 s3Client = AmazonS3ClientBuilder.standard()\r\n                      .withRegion(Regions.AP_NORTHEAST_2)\r\n                      .build();\r\n        ObjectMetadata metadata = new ObjectMetadata();\r\n        metadata.setContentLength(chunk.getSize());\r\n        metadata.setContentType(chunk.getContentType());\r\n\r\n        UploadPartRequest partRequest = new UploadPartRequest()\r\n                .withBucketName([s3 bucket 주소])\r\n                .withKey(key)\r\n                .withUploadId(uploadId)\r\n                .withPartNumber(partNumber)\r\n                .withInputStream(chunk.getInputStream())\r\n                .withPartSize(chunk.getSize());\r\n\r\n        UploadPartResult partResult = s3Client.uploadPart(partRequest);\r\n\r\n        return ResponseEntity.ok(UploadedPart.builder()\r\n                .eTag(partResult.getETag())\r\n                .partNumber(partNumber)\r\n                .build()\r\n              );\r\n  }\r\n\r\n  // Multipart File을 하나의 파일로 합치는 API\r\n  @PostMapping(value = \"/api/upload/server/complete\")\r\n  public ResponseEntity<String> completeMultipartUpload(\r\n          @RequestBody FileUploadCompleteRequest fileUploadCompleteRequest\r\n          //uploadId, key, parts 세개를 받고있고, parts는 partNumber와 eTag를 받고있습니다.\r\n  ) {\r\n      // AWS SDK\r\n      AmazonS3 s3Client = AmazonS3ClientBuilder.standard()\r\n                    .withRegion(Regions.AP_NORTHEAST_2)\r\n                    .build();\r\n\r\n      try {\r\n        List<PartETag> partETags = fileUploadCompleteRequest.getParts().stream()\r\n                .map(p -> new PartETag(p.getPartNumber(), p.getETag()))\r\n                .toList();\r\n\r\n        CompleteMultipartUploadRequest completeRequest = new CompleteMultipartUploadRequest(\r\n                [s3 bucket 주소],\r\n                fileUploadCompleteRequest.getKey(),\r\n                fileUploadCompleteRequest.getUploadId(),\r\n                partETags\r\n        );\r\n\r\n        s3Client.completeMultipartUpload(completeRequest);\r\n      } catch  (Exception e) {\r\n        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\r\n            .body(\"Complete failed\");\r\n      }\r\n\r\n      return new ResponseEntity.ok(\"완료\");\r\n  }\r\n\r\n  @Data\r\n  @Builder\r\n  @NoArgsConstructor\r\n  @AllArgsConstructor\r\n  public class FileUploadCompleteRequest {\r\n          @Schema(description = \"uploadId\", name=\"uploadId\")\r\n          private String uploadId;\r\n\r\n          @Schema(description = \"fileSavePath\", name=\"fileSavePath\")\r\n          private String fileSavePath;\r\n\r\n          @Schema(description = \"parts\", name=\"parts\")\r\n          private List<UploadedPart> parts;\r\n  }\r\n\r\n```\r\n\r\n### 구현 후 업로드 속도 비교\r\n\r\n1. Presigned URL 파일 업로드\r\n\r\n   1. 단일\r\n      1. 기존 : 50MB / 10초 => 네트워크 망 개선 전 : 50MB / 14분\r\n   2. Multipart File\r\n      1. 네트워크 망 개선 전 : 50MB / 2분\r\n\r\n2. 서버에 파일을 올려서 S3에 업로드\r\n   1. 단일\r\n      1. 네트워크 망 개선 전 : 50MB / 18초, 100MB / 30초\r\n   2. Multipart File\r\n      1. 네트워크 망 개선 전 : 50MB / 18초, 100MB / 38초\r\n\r\n결과\r\n\r\n1. 네트워크 망이 좋지 않은 경우 서버에 파일을 올리는게 획기적으로 빨랐다.\r\n2. 서버에 파일을 업로드하여 S3에 올리는 경우, 오히려 Multipart File을 이용하면 더 느리다.\r\n\r\n### 이후 네트워크 망 속도 개선 된 후 업로드 속도\r\n\r\n1. Presigned URL 파일 업로드\r\n\r\n   1. 단일\r\n      1. 네트워크 망 개선 전 : 50MB / 14분\r\n      2. 네트워크 망 개선 후 : 50MB / 14초, 100MB / 30초\r\n   2. Multipart File\r\n      1. 네트워크 망 개선 전 : 50MB / 2분\r\n      2. 네트워크 망 개선 후 : 50MB / 4초, 100MB / 6초\r\n\r\n2. 서버에 파일을 올려서 S3에 업로드\r\n   1. 단일\r\n      1. 네트워크 망 개선 전 : 50MB / 18초, 100MB / 30초\r\n      2. 네트워크 망 개선 후 : 50MB / 18초, 100MB / 30초\r\n   2. Multipart File\r\n      1. 네트워크 망 개선 전 : 50MB / 18초, 100MB / 38초\r\n      2. 네트워크 망 개선 후 : 50MB / 18초, 100MB / 38초\r\n\r\n## 결과\r\n\r\n1. 네트워크 망 개선 전에는 클라이언트에서 S3 접근 속도가 비정상적으로 느렸다. 그래서 Multipart로 파일을 업로드 시켜도 엄청나게 속도가 개선이 되었지만, 아직도 느렸다.\r\n2. 서버로 파일을 올리는건 네트워크 망이 느려진 곳에 거치지 않는 것으로 판단된다. 그래서 네트워크 망이 개선되기 전까지 서버에 파일을 업로드 시켜서 S3에 넣을 수 있도록 하였다.\r\n3. 무조건 Multipart File이 좋진 않았다. 서버에 Multipart File을 올리는 경우 단일로 올리는 것보다 속도가 느렸다.\r\n\r\n## 고촬\r\n\r\n1. 네트워크 망이 안좋았는데 왜 서버로 파일을 올리는건 빨랐을까?\r\n\r\n   프론트 서버와 백엔드 서버 둘다 AWS에 있다.\r\n\r\n   클라이언트 => 무수히 많은 방화벽 => 백엔드\r\n\r\n   아마 내 예상으로 네트워크 이슈가 AWS 서버까지가 아니고 AWS S3 서버까지에서 이슈가 있었던 것으로 판단된다. 그래서 클라이언트에 AWS 서버로 파일이 올라가는건 정상적인 속도가 나왔고, AWS 서버와 S3 서버 끼리도 속도가 빨랐던것 같다.\r\n\r\n2. Multipart File로 파일을 올리는 경우 속도가 자른 파일 개수만큼 빨라질 것이라 판단했으나 그렇지 않았다. 그 이유는 무엇일까?\r\n\r\n   브라우저에서 API을 호출할 때 100MB면 10MB단위로 잘랐기 때문에 10번의 요청을 보냈다. 각 요청마다 서버가 감당하지 못하고, 느리게 처리된 것이다. 그럼 왜 서버가 감당하지 못했냐면? MultipartFile은 스트리밍 방식이 사실 아니었기 때문... MultipartFile을 InputSrteam으로 바꾸었으면 조금 달라지지 않았을까 한다.\r\n"},{"excerpt":"리액트에서 URL 이동시 감지하여 원하는 로직을 넣어보자 🧪 테스트 환경 React v18 AWS SDK for Java1.x 배경 파일 저장소가 변경되어 S3에 파일 업로드를 구축하려한다. 목표 내부 스토리지에 파일 업로드 하는 경우 프론트에서 백엔드로 파일을 업로드한다. 보통 보안을 위해 클라이언트에서 스토리지 접근을 막거나, 서버 안에 파일을 적재하…","fields":{"slug":"/posts/springboot/presined-url/"},"frontmatter":{"date":"April 18, 2025","title":"SpringBoot, React, S3 Presigned URL을 이용하여 파일 업로드를 해보자","tags":["react","springboot"],"emoji":"🚀","series":"SpringBoot"},"rawMarkdownBody":"\r\n# 리액트에서 URL 이동시 감지하여 원하는 로직을 넣어보자\r\n\r\n## 🧪 테스트 환경\r\n\r\n> React v18\r\n>\r\n> AWS SDK for Java1.x\r\n\r\n## 배경\r\n\r\n파일 저장소가 변경되어 S3에 파일 업로드를 구축하려한다.\r\n\r\n## 목표\r\n\r\n내부 스토리지에 파일 업로드 하는 경우 프론트에서 백엔드로 파일을 업로드한다.\r\n\r\n보통 보안을 위해 클라이언트에서 스토리지 접근을 막거나, 서버 안에 파일을 적재하는 경우가 있기 때문이다.\r\n\r\n그래서 프론트에서 백엔드로 파일을 스트리밍 형식으로 업로드하고 S3에 업로드 하는 방법과 AWS S3를 사용하기 때문에 서버를 거치지 않고 Presigned URL을 이용하여 AWS S3에 파일을 올리려 한다.\r\n\r\n1. 프론트에서 스트리밍 형식으로 백엔드로 파일을 S3에 업로드하는 방법\r\n\r\n   자바에서 파일을 다루는 경우 파일 자체가 메모리에 올라가기 때문에 OOM을 일으킬 수 있다.\r\n   그래서 스트리밍 방식을 통해 메모리 부담 없이 파일을 올려보도록 하자\r\n\r\n2. 프론트에서 AWS S3 Presigned URL을 이용하여 파일을 업로드하는 방법\r\n\r\n## 구현\r\n\r\n### 1. 프론트에서 스트리밍 형식으로 백엔드로 파일을 S3에 업로드하는 방법\r\n\r\n```javascript\r\n  export const FileUploader = forwardRef(props, ref) => {\r\n    const [files, setFiles] = useState<File[]>([]);\r\n\r\n    useImperativeHandle(ref, () => ({\r\n      saveFiles: () => onSaveFiles,\r\n    }))\r\n\r\n    const onSaveFiles = () => {\r\n      // 1. 서버에 스트리밍 방식으로 file을 올리는 로직\r\n      await processUploadFilesWithStreaming(files);\r\n    }\r\n\r\n    // 1. 서버에 스트리밍 방식으로 file을 올리는 로직\r\n    async function processUploadFilesWithStreaming(newFiles: File[]) {\r\n      const formData = new FormData();\r\n      Array.from(newFiles).forEach((file) => {\r\n        formData.append('files', file); // files는 서버에서 List<MultipartFile>로 받음\r\n      });\r\n\r\n      await axios.post(\"/api/upload\", formData, {\r\n        headers: {\r\n          \"Content-Type\": \"multipart/form-data\", // 생략해도 브라우저가 알아서 넣음\r\n        },\r\n      });\r\n    }\r\n\r\n    return ...\r\n  }\r\n```\r\n\r\n```java\r\n  @PostMapping(\"/api/upload/server\")\r\n  public ResponseEntity<?> uploadFilesS3(@RequestParam(\"files\") MultipartFile[] files) {\r\n    for (MultipartFile file : files) {\r\n      try {\r\n        // S3에 저장될 키 값(S3 내에서는 파일명으로 봐도 된다.)\r\n        String key = \"upload/\" + UUID.randomUUID() + \"_\" + file.getOriginalFileName();\r\n\r\n        // file.getInputStream()으로 접근시 메모리에 올리지 않고 스트리밍 형식으로 동작\r\n        // 만약 byte[], file.transferTo() 같은 경우는 Heap에 올려서 버퍼링하기 때문에 지양해야함.\r\n        InputStream inputStream = file.getInputStream();\r\n        ObjectMetadata metadata = new ObjectMetadata();\r\n        metadata.setContentType(file.getContentType());\r\n        metadata.setContentLength(file.getSize());\r\n\r\n\r\n        AmazonS3 s3Client = AmazonS3ClientBuilder.standard()\r\n                    .withRegion(Regions.AP_NORTHEAST_2)\r\n                    .build();\r\n\r\n        // S3에 MultiFile을 올리는 함수\r\n        s3Client.putObject(new PutObjectRequest([s3 bucket 주소], key, inputStream, metadata));\r\n\r\n      } catch (Exception e) {\r\n        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\r\n            .body(\"Upload failed for file: \" + file.getOriginalFilename());\r\n      }\r\n    }\r\n\r\n    return ResponseEntity.ok(\"업로드 성공\");\r\n  }\r\n```\r\n\r\n> 질문\r\n> Q1. 스트리밍 방식이 무엇인가요?\r\n>\r\n> A1. 데이터를 한 번에 처리하지 않고, 일정 단위로 끊어서 순차적으로 처리하는 방식. EKS 같은 메모리를 적게 할당하는 시스템인 경우 파일을 처리할 때 스트리밍 방식을 이용하지 않는다면, 파일 객체를 메모리를 그대로 담기 때문에 OOM이 일어날 수 있음.\r\n>\r\n> Q2. POST로 body에 담아 보냈는데 스프링 부트에서는 @RequestParam으로 받나요? @RequestBody가 아닌가요?\r\n>\r\n> A2. 프론트에서 FormData를 보내는 경우, FormData는 브라우저에서 Content-Type을 기본적으로 multipart/form-data형식으로 보내기 때문에, 스프링은 @RequestParam으로 받아야 함. 즉, Content-Type 때문이다.\r\n\r\n### 2. Presigned Url로 파일을 올리는 방법\r\n\r\n```javascript\r\n  export const FileUploader = forwardRef(props, ref) => {\r\n    const [files, setFiles] = useState<File[]>([]);\r\n\r\n    useImperativeHandle(ref, () => ({\r\n      saveFiles: () => onSaveFiles,\r\n    }))\r\n\r\n    const onSaveFiles = () => {\r\n      // 2. presigned Url로 파일을 올리는 로직\r\n      await processUploadFilesWithPresignedUrl(files);\r\n    }\r\n\r\n    // 2. presigned Url로 파일을 올리는 로직\r\n    async function processUploadFilesWithPresignedUrl(newFiles: File[]) {\r\n      const fileSizeArr: number[] = [];\r\n      const fileNameArr: String[] = [];\r\n      const fileTypeArr: String[] = [];\r\n\r\n      Array.from(newFiles).forEach((file) => {\r\n        fileSizeArr.push(file.size);\r\n        fileNameArr.push(file.name);\r\n        fileTypeArr.push(file.type);\r\n      })\r\n\r\n      // Presigned URL을 파일 정보들을 보내서 서버에서 가져옴\r\n      const preSignedUrlResponse = await axios.get(\"/api/upload/presigned-url\", {\r\n        params: {\r\n          fileSizeList: fileSizeArr,\r\n          fileNameList: fileNameArr,\r\n          fileTypeList: fileTypeArr\r\n        },\r\n      });\r\n\r\n      if (preSignedUrlResponse) {\r\n        // PreSigned URL가지고 각 파일 업로드\r\n        for (const idx in preSignedUrlResponse) {\r\n          await axios.put(preSignedUrlResponse[idx].preSignedUrl, newFiles[idx], {\r\n            headers: {\r\n              'Content-Type': newFiles[idx].type,\r\n            },\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    return ...\r\n  }\r\n```\r\n\r\n```java\r\n  @PostMapping(\"/api/upload/presigned-url\")\r\n  public ResponseEntity<List<String>> getPresignedUrl (\r\n    @RequestParam(\"fileSizeList\") List<int> fileSizeList,\r\n    @RequestParam(\"fileNameList\") List<String> fileNameList,\r\n    @RequestParam(\"fileTypeList\") List<String> fileTypeList\r\n  ) {\r\n    List<Strng> presginedUrlList = new ArrayList<>();\r\n\r\n    for (int i = 0; i < fileNameList.size(); i++) {\r\n      try {\r\n        int fileSize = fileSizeList.get(i);\r\n        String fileType = fileTypeList.get(i);\r\n\r\n        // S3에 저장될 키 값(S3 내에서는 파일명으로 봐도 된다.)\r\n        String key = \"upload/\" + UUID.randomUUID() + \"_\" + fileNameList.get(i);\r\n\r\n        // AWS SDK\r\n        AmazonS3 s3Client = AmazonS3ClientBuilder.standard()\r\n                      .withRegion(Regions.AP_NORTHEAST_2)\r\n                      .build();\r\n\r\n        // Pre-Signed URL 만료 시간 (60분 후)\r\n        Date expiration = new Date();\r\n        long expTimeMillis = expiration.getTime();\r\n        // 10분 후 만료\r\n        expTimeMillis += TimeUnit.MINUTES.toMillis(10);\r\n        expiration.setTime(expTimeMillis);\r\n\r\n        // PUT Pre-Signed URL (PUT)\r\n        GeneratePresignedUrlRequest generatePresignedUrlRequest =\r\n                new GeneratePresignedUrlRequest([s3 bucket 주소], key)\r\n                        .withMethod(HttpMethod.PUT)\r\n                        .withContentType(fileType)\r\n                        .withExpiration(expiration);\r\n\r\n        URL url = s3Client.generatePresignedUrl(generatePresignedUrlRequest);\r\n        presginedUrlList.add(url.toString());\r\n\r\n      } catch (Exception e) {\r\n        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\r\n            .body(\"Presigned URL failed for file: \" + fileNameList.get(i) + \". Error: \" + e.getMessage());\r\n      }\r\n    }\r\n\r\n    return ResponseEntity.ok(presginedUrlList);\r\n  }\r\n```\r\n\r\n> 질문\r\n> Q1. Presigned URL을 왜 사용하나요?\r\n>\r\n> A1. 서버에 파일을 올리지 않고 S3에 직접 파일을 올릴 수 있어, 서버 부담을 현저히 줄힐 수 있음\r\n>\r\n> Q2. 보안에는 안좋지 않을까요?\r\n>\r\n> A2. 물론 Presigned URL이 유출되면 좋진 않지만, HTTPS로 URL을 받아 사용하고, 유효기간을 설정하여서 쓰기 때문에 적절하게 쓰면 괜찮다. 물론 CORS 설정으로 원하는 URL에서만 들어오게 하면 보안 설정할 수 있다.\r\n\r\n## 결과\r\n\r\n간단한 형태의 서버 업로드와 Presigned URL 업로드를 해봤다. AWS S3를 사용하는 경우 간단한 방식으로 서버에 부담 없게 파일 업로드를 구현할 수 있다.\r\n\r\n## 고촬\r\n\r\n파일 업로드를 서버가 맡지 않고, 클라이언트에게 맡기는 것이기 때문에, AWS S3가 클라이언트에서 접근이 되어야 한다는점.\r\n\r\nAWS S3 접근이 어렵거나, AWS 접근 망 속도가 느리면 파일업로드가 느린 일이 생긴다.\r\n\r\n실제로 운영하는 시스템에서 생긴 일이기 때문에 다음 글은 파일 업로드 속도 개선 작업에 대해 작성할 것이다.\r\n\r\n파일 업로드를 네 가지 방법을 비교해볼 것이다.\r\n"},{"excerpt":"배경  맥에서 구축된 프론트 프로젝트를 윈도우에서 켰을 때 보통 보이는 사진이다. 전체 화면에 빨갛게 오류로 나오니 정신 나갈 것 같다. 문제정의 CRLF와 LF가 무엇인가? 줄바꿈 방식의 차이라고 생각하면 된다. 윈도우는 , 맥, 리눅스는  으로 줄바꿈 처리를 진행한다. 그래서 윈도우는  +  ==  +  로 표시하는 것이고, 맥과 리눅스는  ==  으…","fields":{"slug":"/posts/react/crlf/"},"frontmatter":{"date":"April 06, 2025","title":"CRLF LF","tags":["CRLF","LF"],"emoji":"🚀","series":"React"},"rawMarkdownBody":"\r\n## 배경\r\n\r\n![CRLF error](./../../../images/react/crlf-error-screenshot.png)\r\n\r\n맥에서 구축된 프론트 프로젝트를 윈도우에서 켰을 때 보통 보이는 사진이다.\r\n\r\n전체 화면에 빨갛게 오류로 나오니 정신 나갈 것 같다.\r\n\r\n## 문제정의\r\n\r\n### CRLF와 LF가 무엇인가?\r\n\r\n줄바꿈 방식의 차이라고 생각하면 된다.\r\n\r\n윈도우는 `/r/n`, 맥, 리눅스는 `\\n` 으로 줄바꿈 처리를 진행한다.\r\n\r\n그래서 윈도우는 `CR` + `LF` == `\\r` + `\\n` 로 표시하는 것이고,\r\n\r\n맥과 리눅스는 `LF` == `\\n` 으로 표기하는 것이다.\r\n\r\n> 줄바꿈, line break, EOL(End Of Line)\r\n\r\n### 왜 이런 일이 일어났을까?\r\n\r\n나는 윈도우에서 이 프로젝트를 깃으로 받아 vs code로 켰다.\r\n\r\n그러나 이 프로젝트는 맥에서 만들어진 프로젝트였지만, 깃에 올렸을 때 `LF` 형식으로 올리지 않아서 생긴 이슈로 판단된다.\r\n\r\n### 저 에러는 어디서 내뱉는 걸까?\r\n\r\n이 에러는 `eslint`에서 내뱉는 것이다. 그래서 `.eslintrc.cjs` 파일을 열어 설정 중 `linebreak-style` 내용을 확인해보자.\r\n\r\n```\r\n{\r\n  'linebreak-style': ['error', 'unix']\r\n}\r\n```\r\n\r\n### CRLF와 LF 중 무엇을 선택해야하는가?\r\n\r\n가장 고민되는 사실일 것이다. 그러나 정답은 거의 정해져있다.\r\n\r\n1. `\\r\\n`과 `\\n`은 바이트 크기 차이가 있다.\r\n2. 리눅스나 맥에서 `\\r`은 줄바꿈 오류로 실행된다.\r\n3. `LF`는 표준이다.\r\n\r\n즉, LF를 사용하자.\r\n\r\n## 행동\r\n\r\n### CRLF를 LF로 변경하자\r\n\r\n- Prettier를 이용하여 전체 파일의 `CRLF`를 `LF`로 변경시킬 것이다.\r\n\r\n1. Prettier 설치 확인\r\n\r\n   ```sh\r\n   npx prettier -v\r\n   ```\r\n\r\n2. 버전이 출력되지 않는다면, Prettier 설치\r\n\r\n   ```sh\r\n    npx install --save-dev prettier\r\n   ```\r\n\r\n3. .prettierrc 파일 생성, LF 설정 적용\r\n\r\n   ```json\r\n   {\r\n     \"endOfLine\": \"lf\"\r\n   }\r\n   ```\r\n\r\n4. 설치한 Prettier를 이용하여 모든 파일을 적용한다.\r\n\r\n   ```sh\r\n   npx prettier --write .\r\n   ```\r\n\r\n![LF error](./../../../images/react/lf-screenshot.png)\r\n\r\n### 예방방법\r\n\r\n1. VSCode 설정\r\n\r\nVSCode 설정(crtl + ,)으로 들어가 eol을 검색한다.\r\n\r\n![VSCode EOL 설정](./../../../images/react/vscode-eol-screenshot.png)\r\n\r\n이곳에서 `\\n`으로 기본값을 변경한다.\r\n\r\n2. Git 커밋 설정\r\n\r\n```sh\r\n  git config --global core.autocrlf false\r\n  git config --global core.eol lf\r\n```\r\n\r\n## 결과\r\n\r\nCRLF와 LF의 차이를 알고 한꺼번에 처리하는 방법과 예방 방법을 알아보았다~\r\n"},{"excerpt":"리액트에서 URL 이동시 감지하여 원하는 로직을 넣어보자 🧪 테스트 환경 React v18 배경 요청사항으로 페이지 내에서 수정이 일어난 경우 URL을 이동하려고 할 시 confirm 창을 띄워 정말 이동하고 싶은건지 물어보는 기능이 필요하다고 한다. 리액트에서 제공해주는 방식이 없기 때문에 기능을 구현하고자 한다. 목표 리액트에서 URL을 이동할 수 있…","fields":{"slug":"/posts/react/react-prevent-navigate/"},"frontmatter":{"date":"April 02, 2025","title":"리액트에서 뒤로가기, 새로고침, 페이지 이동을 감지해보자","tags":["react"],"emoji":"🚀","series":"React"},"rawMarkdownBody":"\r\n# 리액트에서 URL 이동시 감지하여 원하는 로직을 넣어보자\r\n\r\n## 🧪 테스트 환경\r\n\r\n> React v18\r\n\r\n## 배경\r\n\r\n요청사항으로 페이지 내에서 수정이 일어난 경우 URL을 이동하려고 할 시 confirm 창을 띄워 정말 이동하고 싶은건지 물어보는 기능이 필요하다고 한다.\r\n\r\n리액트에서 제공해주는 방식이 없기 때문에 기능을 구현하고자 한다.\r\n\r\n## 목표\r\n\r\n리액트에서 URL을 이동할 수 있는 방법은 `Link 컴포넌트`, `useNavigate`, 뒤로가기, 새로고침, 앞으로가기가 있다.\r\n\r\n1. 제어가 안되는 `useNavigate` 훅과 `Link` 컴포넌트를 다른 방식으로 동작하도록 할 것\r\n2. 뒤로가기와 새로고침의 경우 브라우저의 이벤트를 이용하여 막을 것\r\n\r\n## 기능 추가\r\n\r\n1. 뒤로가기, 새로고침 이벤트 설정\r\n\r\n   뒤로가기와 새로고침을 막고자 하는 컴포넌트에 커스텀 훅을 넣어줘서 동작을 제어해보자.\r\n\r\n   ```javascript\r\n   //usePreventRefresh.ts\r\n   export const usePreventPageExit = () => {\r\n    const navigate = useNavigate();\r\n    const isModified =\r\n    /* 이곳에는 isModified를 전역으로 관리할 수 있는 방법을 이용한다.\r\n     * 상태값보단 불필요한 렌더링을 일으키지 않는 useRef 객체를 이용는 것을 추천합니다.\r\n     */\r\n\r\n    // 새로고침 이벤트 핸들러 함수\r\n    // 새로고침시 이벤트를 막는다면, 브라우저에서 지정해놓은 confirm 창이 뜬다.\r\n    const handleBeforeunload = (event) => {\r\n      if (isModified) {\r\n        event.preventDefault();\r\n        event.returnValue = '';\r\n      }\r\n    }\r\n\r\n    // 뒤로가기 이벤트 핸들러 함수\r\n    /* 방식\r\n     * 1. 첫 화면 렌더링시 window의 history 객체에 현재 주소로된 이력을 넣는다.\r\n     * 2. 뒤로가기 클릭시 이전 이력이 현재 주소이기 때문에 브라우저 화면이 다시\r\n          로드되지  않고, 현재 화면에 그대로 있는다.\r\n     * 3. window의 history 객체에 현재 주소로된 이력을 한 번 더 넣는다.\r\n     * 4. 사용자의 yes, no 클릭을 이용해 다음 행동을 결정짓는다.\r\n     * 4-1. yes 클릭\r\n        현재 히스토리에는 3번에서 넣은 이력으로 인해 2번 뒤로가도록 한다.\r\n       4-2. no 클릭\r\n        히스토리에 현재 주소 이력이 있어야하기 때문에 아무일도 일어나지 않는다.\r\n     */\r\n    const handlePopstate = () => {\r\n      if (isModified) {\r\n        history.pushState(null, '', location.href);\r\n        if (confirm('뒤로가시겠습니까? 작성된 내용은 저장이 되지 않습니다.')) {\r\n          navigate(-2);\r\n        }\r\n      } else {\r\n        navigate(-1);\r\n      }\r\n    }\r\n\r\n    useEffect(() => {\r\n      // 컴포넌트가 마운트되면 이벤트 생성 및 현재 주소 이력 추가\r\n      window.addEventListener('beforeunload', handleBeforeunload);\r\n      history.pushState(null, '', location.href);\r\n      window.addEventListener('popstate', handlePopstate);\r\n\r\n      return () => {\r\n        // 컴포넌트가 언마운트되면 이벤트를 제거한다.\r\n        window.removeEnventListener('beforeunload', handleBeforeunload);\r\n        window.removeEnventListener('popstate', handlePopstate);\r\n      }\r\n    }, [])\r\n   };\r\n   ```\r\n\r\n2. `useNavigate` 훅 커스텀\r\n\r\n`navigate('???')` 방식으로 리액트에서 페이지 이동을 시킨 경험이 있을 것 입니다. 위 처럼 페이지 이동시에 이벤트를 감지해서 막을 수 있지 않을까? 라는 생각을 했으면 바람직한 생각입니다. 그러나 `navigate` 함수가 실행이 되면, 중간에서 이벤트로 막을수가 없기 때문에 훅을 커스텀해서 사용해야 합니다. 저는 아래와 같이 사용했지만 절대로 정답은 아닙니다.\r\n\r\n```javascript\r\n  const useCustomNavigate = () => {\r\n    const navigate = useNavigate();\r\n    const isModified =\r\n    /* 이곳에는 isModified를 전역으로 관리할 수 있는 방법을 이용한다.\r\n     * 상태값보단 불필요한 렌더링을 일으키지 않는 useRef 객체를 이용는 것을 추천합니다.\r\n     */\r\n\r\n    const customNavigate = (to: To, options?: NavigateOptions, callback?: () => void) => {\r\n      if (isModified) {\r\n        if (confirm('이동하시겠습니까? 작성된 내용은 저장이 되지 않습니다.')) {\r\n          navigate(to, options);\r\n          isModified = false;\r\n          callback && callback();\r\n        } else {\r\n          navigate(to, options);\r\n          callback && callback();\r\n        }\r\n      }\r\n    }\r\n\r\n    return customNavigate;\r\n  }\r\n\r\n  export default useCustomNavigate();\r\n```\r\n\r\n3. 사용 방법\r\n\r\n   ```javascript\r\n    const BoardRegistPage = () => {\r\n      const navigate = useCustomNavigate();\r\n      const isModified =\r\n      /* 이곳에는 isModified를 전역으로 관리할 수 있는 방법을 이용한다.\r\n       * 상태값보단 불필요한 렌더링을 일으키지 않는 useRef 객체를 이용는 것을 추천합니다.\r\n       */\r\n\r\n      // 수정이 되었을 때 부터 이동 감지를 하고자 원한다면 이런 방식으로,\r\n      // 컴포넌트가 마운트 되자마자 막고 싶다면, useEffect를 이용\r\n      const handleChange = () => {\r\n        isModified = true;\r\n        ...\r\n      }\r\n\r\n      // isModified가 true면, navigate 함수에서 이동을 막는 로직이 실행된다.\r\n      const handleClick = () => {\r\n        navigate('/test');\r\n      }\r\n\r\n      return (\r\n        <>\r\n          {/* Link 컴포넌트는 to에 이동하지 않도록 #을 넣어주고, 이동 방식은 onClick을 이용하여 이동을 막도록 한다.*/}\r\n          <Link\r\n            to=\"#\"\r\n            onClick={handleClick}\r\n          >이동</Link>\r\n\r\n          ...\r\n        </>\r\n      )\r\n    }\r\n   ```\r\n\r\n   4. 전역으로 사용할 변수 `isModified`\r\n\r\n   `isModified` 는 전역으로 사용할 변수를 이용한다.\r\n\r\n   1. 컴포넌트 밖에서 선언한 let 변수 (권장안함)\r\n   2. 상태관리 라이브러리 (zustand, Redux 등) (상태값으로 선언시 불필요한 리렌더링 유발)\r\n   3. `useRef` 객체 (권장)\r\n\r\n   위 내용을 기반으로 `Context` 에 `useRef` 객체로 선언된 `isModified`를 불러와서 사용하자.\r\n\r\n   이 경우 불필요한 리렌더링을 안하기 때문에 편리하게 사용할 수 있고, 어디서든 불러와서 사용할 수 있다.\r\n"},{"excerpt":"🧪 테스트 환경 아래 명령어를 통해  템플릿을 이용하는 사람의 경우거나 블로그에 댓글을 를 통해 만들고 싶은 경우 참고만 하면 된다. 🍳 giscus가 무엇인가? giscus는 의 을 통해 댓글 기능을 만들어주는 편리한 라이브러리입니다. 개발자는 에서  기능을 열어두고, giscus 홈페이지에서  주소와 여러 설정을 추가하면 giscus 정보를 받을 수 …","fields":{"slug":"/posts/how-to/giscus/"},"frontmatter":{"date":"March 13, 2025","title":"giscus 시작하기","tags":["gatsby"],"emoji":"✋","series":"gatsby"},"rawMarkdownBody":"\r\n## 🧪 테스트 환경\r\n\r\n아래 명령어를 통해 `gatsby-starter-rundevelrun` 템플릿을 이용하는 사람의 경우거나 블로그에 댓글을 `github`를 통해 만들고 싶은 경우 참고만 하면 된다.\r\n\r\n```shell\r\ngatsby new your-blog-name https://github.com/rundevelrun/gatsby-starter-rundevelrun.git\r\n```\r\n\r\n## 🍳 giscus가 무엇인가?\r\n\r\ngiscus는 `github repository`의 `Discussion`을 통해 댓글 기능을 만들어주는 편리한 라이브러리입니다.\r\n\r\n개발자는 `github repository`에서 `Discussion` 기능을 열어두고, giscus 홈페이지에서 `github repository` 주소와 여러 설정을 추가하면 giscus 정보를 받을 수 있습니다.\r\n\r\n## ☝ giscus 설정 방법\r\n\r\n1. 댓글 데이터를 담아둘 `repository`에 접속한다.\r\n   - `public repository`인지 확인한다.\r\n   - [giscus 설치 페이지](https://github.com/apps/giscus) 접속하여 giscus를 설치한다.\r\n   - `repository settings`로 들어가서 `Features`에 있는 `Discussions` 체크박스에 체크한다.\r\n2. [giscus 홈페이지](https://giscus.app/ko) 접속하여 설정한다.\r\n   - 저장소 명을 입력한다.\r\n   - Discussions 연결 방법을 선택한다.\r\n   - Discuussion 카테고리를 선택한다. (Announcements를 권장합니다.)\r\n   - 원하는 테마와 기능을 설정하고, `giscus script`를 복사한다.\r\n   ```javascript\r\n   //예시\r\n   <script\r\n     src=\"https://giscus.app/client.js\"\r\n     data-repo=\"[ENTER REPO HERE]\"\r\n     data-repo-id=\"[ENTER REPO ID HERE]\"\r\n     data-category=\"[ENTER CATEGORY NAME HERE]\"\r\n     data-category-id=\"[ENTER CATEGORY ID HERE]\"\r\n     data-mapping=\"pathname\"\r\n     data-strict=\"0\"\r\n     data-reactions-enabled=\"1\"\r\n     data-emit-metadata=\"0\"\r\n     data-input-position=\"bottom\"\r\n     data-theme=\"preferred_color_scheme\"\r\n     data-lang=\"ko\"\r\n     crossorigin=\"anonymous\"\r\n     async\r\n   ></script>\r\n   ```\r\n\r\n## ✌ 개인 블로그에서 giscus 컴포넌트 만들어서 사용하기\r\n\r\n1. giscus 라이브러리 설치\r\n\r\n   ```shell\r\n   npm i giscus\r\n   ```\r\n\r\n2. 컴포넌트 생성\r\n\r\n   `giscus script`에서 받은 데이터를 컴포넌트에 넣어서 사용하면 완성!\r\n\r\n   ```javascript\r\n   import Giscus from '@giscus/react';\r\n\r\n   export default function MyApp() {\r\n     return (\r\n       <Giscus\r\n         id=\"comments\"\r\n         repo=\"[ENTER REPO HERE]\"\r\n         repoId=\"[ENTER REPO ID HERE]\"\r\n         category=\"[ENTER CATEGORY NAME HERE]\"\r\n         categoryId=\"[ENTER CATEGORY ID HERE]\"\r\n         mapping=\"pathname\"\r\n         term=\"Welcome to @giscus/react component!\"\r\n         reactionsEnabled=\"1\"\r\n         emitMetadata=\"0\"\r\n         inputPosition=\"bottom\"\r\n         theme=\"light\"\r\n         lang=\"ko\"\r\n         loading=\"lazy\"\r\n       />\r\n     );\r\n   }\r\n   ```\r\n\r\n   > [giscus Github 주소](https://github.com/giscus/giscus-component) 참고하였습니다.\r\n\r\n## ✌ rundevelrun/gatsby-starter-rundevelrun 템플릿 전용 설정\r\n\r\n`blog-config.js`의 내용 수정\r\n\r\n```javascript\r\nmodule.exports = {\r\n   ...\r\n   links: {\r\n      ...\r\n   },\r\n   giscus: {\r\n      repo=\"[ENTER REPO HERE]\"\r\n      repoId=\"[ENTER REPO ID HERE]\"\r\n      category=\"[ENTER CATEGORY NAME HERE]\"\r\n      categoryId=\"[ENTER CATEGORY ID HERE]\"\r\n      mapping=\"pathname\"\r\n      strict=\"0\"\r\n      reactionsEnabled: '1',\r\n      inputPosition=\"bottom\"\r\n      lang: 'ko',\r\n   },\r\n   adsense: {\r\n      ...\r\n   }\r\n}\r\n```\r\n\r\n## 👍 댓글 창 확인\r\n\r\n![giscus 댓글 스크린샷](./../../../images/how-to/giscus-screenshot.png)\r\n"},{"excerpt":"리액트 폴더구조 회사에서 처음 리액트 프로젝트를 시작할 때 가장 이해가 안되던 부분이 폴더구조였다.\r\n당시  폴더 아래에는 메뉴 단위로 가져갔고, 공통 컴포넌트는  아래에 파일 단위로만 들어가 있었다.\r\n또한 와 의 차이를 몰랐었다. 중간에 프로젝트를 투입하게 되면서 내가 보는 페이지가 어떤 파일인지 유추가 안되고, 파일을 어디에 둬야할지 고민이 되었다.…","fields":{"slug":"/posts/react/react-folder/"},"frontmatter":{"date":"March 11, 2025","title":"React Folder","tags":["react"],"emoji":"🚀","series":"React"},"rawMarkdownBody":"\r\n# 리액트 폴더구조\r\n\r\n회사에서 처음 리액트 프로젝트를 시작할 때 가장 이해가 안되던 부분이 폴더구조였다.\r\n당시 `src` 폴더 아래에는 메뉴 단위로 가져갔고, 공통 컴포넌트는 `components` 아래에 파일 단위로만 들어가 있었다.\r\n또한 `public/assets`와 `src/assets`의 차이를 몰랐었다.\r\n\r\n중간에 프로젝트를 투입하게 되면서 내가 보는 페이지가 어떤 파일인지 유추가 안되고, 파일을 어디에 둬야할지 고민이 되었다.\r\n\r\n다른 사람들은 어떤 폴더구조를 쓸까? 에 대한 내용과 내가 사용하는 폴더 구조를 소개하려고 한다.\r\n\r\n> 기본적으로 폴더구조는 프로젝트 상황과 사용하는 라이브러리, 디자인 패턴에 맞게 수정하는게 맞다고 생각한다.\r\n\r\n## create-react-app 폴더구조\r\n\r\n```\r\nmy-app/\r\n├── node_modules/       # 프로젝트에 필요한 모든 의존성이 저장되는 폴더\r\n├── public/             # 정적 파일이 저장되는 폴더\r\n│   ├── favicon.ico     # 브라우저 탭에 표시되는 아이콘\r\n│   ├── index.html      # React 앱이 로드되는 기본 HTML 파일\r\n│   ├── logo192.png     # 기본 제공 로고 이미지 (192x192 크기)\r\n│   ├── logo512.png     # 기본 제공 로고 이미지 (512x512 크기)\r\n│   ├── manifest.json   # PWA 관련 설정 파일\r\n│   ├── robots.txt      # 검색 엔진 크롤러 관련 설정 파일\r\n│   └── ...\r\n├── src/                # 애플리케이션의 주요 소스 코드가 들어가는 폴더\r\n│   ├── App.css         # `App` 컴포넌트의 스타일 정의\r\n│   ├── App.js          # 주요 애플리케이션 컴포넌트\r\n│   ├── App.test.js     # `App` 컴포넌트의 테스트 파일\r\n│   ├── index.css       # 전역 스타일 정의\r\n│   ├── index.js        # 애플리케이션의 진입점 파일\r\n│   ├── logo.svg        # 기본 제공 React 로고 (SVG 형식)\r\n│   ├── reportWebVitals.js # 성능 측정 관련 코드\r\n│   ├── setupTests.js   # 테스트 설정 파일 (Jest)\r\n│   └── ...\r\n├── .gitignore          # Git에서 무시할 파일 목록\r\n├── package.json        # 프로젝트 및 의존성 설정 파일\r\n├── README.md           # 프로젝트 설명 파일\r\n├── yarn.lock / package-lock.json  # 의존성 고정 파일\r\n└── ...\r\n```\r\n\r\n- 리액트를 처음 시작할 때 바로 볼 수 있는 폴더구조이다.\r\n  리액트를 처음 하는 사람한테는 src 내부 구조가 없어 폴더를 어떻게 만들지 고민이 된다.\r\n\r\n### src 폴더 구체화\r\n\r\n```\r\nsrc/\r\n├── components/       # 재사용 가능한 UI 컴포넌트\r\n├── pages/            # 주요 페이지 구성 요소\r\n├── hooks/            # 사용자 정의 훅\r\n├── services/         # API 호출 및 비즈니스 로직\r\n├── types/            # 타입\r\n├── utils/            # 유틸리티 함수\r\n├── context/          # React Context API 관련 코드\r\n└── assets/           # 이미지, 폰트, 아이콘 등 정적 리소스\r\n```\r\n\r\n- Chat GPT는 `src` 구조를 위 처럼 확장하는 것을 추천한다. 페이지 단위로 파일을 만들고, 재사용이 가능한 컴포넌트는 따로 관리하며\r\n  커스텀 훅도 따로 관리한다. 실제로 파일들을 넣어보자\r\n\r\n```\r\nsrc/\r\n├── components/       # 재사용 가능한 UI 컴포넌트\r\n│\t\t└── board-header.tsx\r\n├── pages/            # 주요 페이지 구성 요소\r\n│       └── board-page.tsx\r\n├── hooks/            # 사용자 정의 훅\r\n│\t\t└── use-board.ts\r\n├── services/         # API 호출 및 비즈니스 로직\r\n│\t\t└── board-api.ts\r\n├── types/            # 타입\r\n│\t\t└── board.ts\r\n├── utils/            # 유틸리티 함수\r\n│\t\t└── date-util.ts\r\n├── context/          # React Context API 관련 코드\r\n├── assets/           # 이미지, 폰트, 아이콘 등 정적 리소스\r\n│\t\t└── image1.png\r\n...\r\n```\r\n\r\n- 첫 프로젝트 때 이러한 구조가 되었었다. 게시판을 위 처럼 개발했을 때 수정이 필요한 경우\r\n  광범위하게 흩어진 코드를 찾으러 다녀야해서 너무 힘들었다.\r\n\r\n> 그래서 생각한 것은\r\n>\r\n> 1. URL 경로와 페이지 컴포넌트는 보통 1 : 1 이니까 경로에 맞게 폴더 구조를 만들기\r\n> 2. 특성이 같고, 수정사항이 많은 파일의 경우는 같은 곳에 넣어두자\r\n\r\n## 내가 사용하던 폴더 구조\r\n\r\n- 아래 조건들에 맞춰 `pages` 폴더를 좀더 구체화 하였다.\r\n  - 프로젝트 규모가 작다\r\n  - 라우팅 되는 URL 경로 구조와 `pages` 폴더 구조가 같도록 한다\r\n    - 폴더로 라우팅 구조 파악 가능\r\n  - 중요 로직은 커스텀 훅에서 관리한다\r\n    - UI와 로직 분리\r\n\r\n```\r\nsrc/\r\n├── components/                     # 재사용 가능한 UI 컴포넌트\r\n├── pages/                          # 주요 페이지 구성 요소\r\n│       └── board/                  # URL 경로\r\n│            ├── components/        # 종속된 UI 컴포넌트\r\n│            │    ├── hooks/        # 종속된 커스텀 훅\r\n│\t\t         │    │    └── use-board-header.ts\r\n│\t\t         │    │\r\n│\t\t         │    └── board-header.tsx\r\n│            ├── hooks/             # 종속된 커스텀 훅\r\n│\t\t         │    └── use-board.ts\r\n│            ├── schema/            # hook-form 스키마\r\n│\t\t         │    └── board-schema.ts\r\n│            ├── api/               # API 호출\r\n│\t\t         │    └── board-api.ts\r\n│            ├── models/            # 타입\r\n│\t\t         │    └── board.ts\r\n│            └── board-page.tsx\r\n│\r\n├── hooks/            # 전역으로 사용하는 사용자 정의 훅\r\n├── apis/             # 전역으로 사용하는 API 호출\r\n├── models/           # 전역으로 사용하는 타입\r\n├── utils/            # 유틸리티 함수\r\n├── assets/           # 이미지, 폰트, 아이콘 등 정적 리소스\r\n├── routers/          # 라우팅 관련 컴포넌트\r\n├── stores/           # 상태관리 라이브러리 상태\r\n├── App.tsx           # 최상위 컴포넌트\r\n└──\r\n```\r\n\r\n`board` 경로에는 이제 한 곳에서 소스를 한 눈에 확인할 수 있고, 관리 포인트도 좁아졌다.\r\n프로젝트를 혼자하는 것도 아니고, 새로 들어오는 개발자에게 폴더 구조를 몇 시간동안 강의할 것이 아니라면\r\n이해가 가는 선에서 구조를 만들어주는 방향은 정말 좋은 것 같다.\r\n\r\n또한 커스텀 훅 패턴으로 훅에 로직을 모두 넣어두고 컴포넌트에서 불러오는 방식이 유지보수 방면에서 좋다고 느꼈다.\r\nUI 컴포넌트에서 UI 소스 부분에 서비스 로직이 들어있는 경우 소스 보기가 불편한 경우가 많았다..\r\n\r\n## 유명한 FSD\r\n\r\n위 구조를 보면 `게시판`이라는 특징을 가진 기능을 `board` 폴더로 묶은 모습을 볼 수 있다.\r\n같은 특징을 가진 소스는 한 곳으로 모아두자 라는 느낌으로 묶은 것인데, `feature`와 관련된 유명한 아키텍처 방법론으로 `FSD`가 있다.\r\n물론 내가 사용하던 폴더 구조와는 많이 다르게 생겼다.\r\n`layer`로 둬서 같은 엄격하게 폴더에 들어갈 소스 위치를 구분하고 `feature`에서 기능을 묶는 방법론이다.\r\n\r\n![FSD Scheme.png](FSD Scheme.png)\r\n\r\n위 사진만으로 이해가 되지않지만, FSD 홈페이지를 가보면, 예제와 마이그레이션 방법도 친절히 나와있다.\r\n\r\n[FSD 마이그레이션 방법](https://feature-sliced.design/docs/guides/migration/from-v1) 그 중에 `layer` 내용만 가져와보겠다.\r\n\r\n- FSD Layer\r\n  - /app — application initialization layer\r\n    - Previous versions: app, core, init, src/index (and this happens)\r\n  - /processes — business process layer\r\n    - Previous versions: processes, flows, workflows\r\n  - /pages — application page layer\r\n    - Previous versions: pages, screens, views, layouts, components, containers\r\n  - /features — functionality parts layer\r\n    - Previous versions: features, components, containers\r\n  - /entities — business entity layer\r\n    - Previous versions: entities, models, shared\r\n  - /shared — layer of reused infrastructure code 🔥\r\n    - Previous versions: shared, common, lib\r\n\r\n여기서 크게 `app / pages / features` 만 봐도 좋다.\r\n\r\n```\r\nsrc/\r\n├── app\r\n│       ├── layout/\r\n│       ├── providers/\r\n│       ├── routers/\r\n│       └── App.tsx\r\n├── pages\r\n│       └── board/\r\n│            └── board-page.tsx\r\n├── features\r\n│       └── board/\r\n│            └── ui/\r\n│\t\t          └── board-header.tsx\r\n├── entities\r\n│       └── board/\r\n│\t\t     └── types.ts\r\n├── shared\r\n│       └── api/\r\n│            └── board/\r\n│\t\t          └── board-api.ts\r\n│       └── assets/\r\n│       └── lib/\r\n└──\r\n```\r\n\r\n크게 내용을 넣진 않았지만, `app` > `pages` > `features` > `entities` > `shared` 형식으로 층을 나누어서 자기보다 아래에 있는 층만\r\n참조해서 가져오는 방식이다.\r\n복잡하지만 상당히 큰 프로젝트에는 모든 기능이 나눠져있어 관리하는 부분에선 좋을 것이다.\r\n\r\n## MIT 리액트 아키텍처\r\n\r\n[MIT 리액트 아키텍처](https://github.com/alan2207/bulletproof-react/)\r\n\r\n리액트 아키텍처 구조를 가이드처럼 만들어둔 레포가 있다. `Star 29k` 가 넘어간 유명한 레포며, `feature`를 기준으로 폴더를 설계하였다.\r\n`nextjs 앱`, `nextjs 웹`, `react-vite` 세개의 구조를 보여준다.\r\n\r\n> bulletproof 는 안정적인 코드를 뜻한다.\r\n\r\n```\r\nsrc/\r\n├── features\r\n│       └── comments/\r\n│            └── api/\r\n│\t\t         └── components/\r\n└──\r\n```\r\n\r\n`feature` 폴더 하나를 기준으로 보면, 내가 사용하는 폴더구조와 비슷하게 한 곳에서 관련된 소스들을 관리한다.\r\n하지만 `FSD`와 비슷하게 `app` 폴더에서 어플리케이션 구조를 만든다. `pages` 폴더 없이 `app`폴더에서 모두 관리한다.\r\n\r\n```\r\nsrc/features/awesome-feature\r\n|\r\n+-- api         # exported API request declarations and api hooks related to a specific feature\r\n|\r\n+-- assets      # assets folder can contain all the static files for a specific feature\r\n|\r\n+-- components  # components scoped to a specific feature\r\n|\r\n+-- hooks       # hooks scoped to a specific feature\r\n|\r\n+-- stores      # state stores for a specific feature\r\n|\r\n+-- types       # typescript types used within the feature\r\n|\r\n+-- utils       # utility functions for a specific feature\r\n```\r\n\r\n## 정리\r\n\r\n`FSD`, `bulletproof-react repository`를 구경해봤다. `feature` 폴더에 기능 기준으로 컴포넌트를 만들고, 필요한 `api` 호출이나 종속된 컴포넌트의 경우 같은 공간에 만들어 소스 확인할 때 이리저리 움직이지 않게 만드는 모습을 보인다. `feature` 방식을 이용해볼까 생각중이다. 물론 마이그레이션까지 하면서 진행할 생각은 없다.\r\n\r\n프로젝트가 진행되면서 공통적으로 만들어야하는 기능이 많아지는 경우 `src/component` 폴더가 매우 커졌던 경험이 있다. 즐겨찾기가 되는 버튼형 아이콘을 만들 때 기능에 치중한 컴포넌트이니까 `src/component/feature` 폴더를 만들거나, `src/component/feature` 폴더를 만들어서 한 곳에 만들고, `src/component/ui` 폴더에는 기능이 없는 컴포넌트는 어떤가 싶기도 하다.\r\n\r\n> 운영하는 시스템에서 조금 신경쓰일정도로 느린 화면들이 있는데, `SSR`을 사용하면 조금 나아질까 싶어 Nextjs를 공부하고있다.\r\n>\r\n> 사용하던 폴더구조를 보니 Nextjs의 페이지 라우팅 구조와 비슷한 모습을 보여 놀랐다.\r\n"},{"excerpt":"🧪 테스트 환경 NodeJS v22.13.0 \r\nyarn 1.22.22 🛠️ 환경 설정 NodeJS↗ 설치 yarn 설치 gatsby-cli 설치 Gatsby 블로그 생성 🚀 개발 환경 구동 아래 과정을 거친 후 으로 접속 의존성 패키지 설치 구동 구동 방법은 사용하는 Gatsby 템플릿마다  에 작성된 yarn 명령어는 다르겠지만, 대부분 동일하게  명령…","fields":{"slug":"/posts/how-to/gatsby/"},"frontmatter":{"date":"January 18, 2025","title":"Gatsby 블로그 시작하기","tags":["gatsby"],"emoji":"✋","series":"gatsby"},"rawMarkdownBody":"\r\n## 🧪 테스트 환경\r\n\r\n> NodeJS v22.13.0 <br/>\r\n> yarn 1.22.22\r\n\r\n## 🛠️ 환경 설정\r\n\r\n1. [NodeJS↗](https://nodejs.org/ko/download) 설치\r\n2. yarn 설치\r\n   ```shell\r\n   npm install -g yarn\r\n   ```\r\n3. gatsby-cli 설치\r\n   ```shell\r\n   yarn global add gatsby-cli\r\n   ```\r\n4. Gatsby 블로그 생성\r\n\r\n   ```shell\r\n   gatsby new [your-blog-name] [사용하고 싶은 Gatsby 템플릿]\r\n\r\n   예시 : gatsby new your-blog-name https://github.com/rundevelrun/gatsby-starter-rundevelrun.git\r\n   ```\r\n\r\n## 🚀 개발 환경 구동\r\n\r\n아래 과정을 거친 후 `http://localhost:8000`으로 접속\r\n\r\n1. 의존성 패키지 설치\r\n\r\n   ```shell\r\n   cd your-blog-name\r\n   yarn install\r\n   ```\r\n\r\n2. 구동\r\n\r\n   구동 방법은 사용하는 Gatsby 템플릿마다 `package.json` 에 작성된 yarn 명령어는 다르겠지만, 대부분 동일하게 `gatsby develop` 명령어를 사용하시면 됩니다.\r\n\r\n   **이후 내용부터는 `https://github.com/rundevelrun/gatsby-starter-rundevelrun.git` 템플릿을 기준으로 설명서가 작성되었습니다.**\r\n\r\n   ```shell\r\n   yarn develop\r\n   ```\r\n\r\n## ☺️ 사용자화\r\n\r\n`blog-config.js`의 내용 수정\r\n\r\n```javascript\r\nmodule.exports = {\r\n  title: \"YOUR:BLOG:NAME\",    // SEO Blog title\r\n  headerTitle: \"YOUR:<em style='color:#ed6c02'>BLOG</em>:NAME\", // Logo 1\r\n  headerSubTitle: \"<em style='color:#ed6c02'>YOUR</em>:BLOG:<em style='color:#ed6c02'>NAME</em>\", // Logo 2\r\n  copyright: \"©YOUR:BLOG:NAME\", // copyright in footer\r\n  author: \"YOUR:NAME\",  // Your Name\r\n  siteUrl: \"https://6developer.com/\", // Your Site URL\r\n  description: \"Hi, Nice to meet you !\",  // Blog description\r\n  links: {\r\n    github: \"https://github.com/rundevelrun\",\r\n    ...\r\n  },\r\n  giscus: {\r\n    ...\r\n  },\r\n  adsense: {\r\n    ...\r\n  }\r\n}\r\n```\r\n\r\n## 📝 게시글 작성\r\n\r\n1. `contents/posts` 폴더에 게시글 파일 생성 (두가지 방법)\r\n   1. pathname으로 사용할 이름의 폴더를 만들고 하위에 'index.md'를 생성\r\n   2. pathname으로 사용할 이름으로 `*.md` 파일 생성\r\n2. frontmatter 작성\r\n   ```yaml\r\n   ---\r\n   emoji: '🚀'\r\n   title: '어떻게 시작할까요?'\r\n   date: 2025-01-19 13:53:00\r\n   update: 2025-01-19 13:53:00\r\n   tags:\r\n     - rundevelrun\r\n     - howto\r\n   series: 'Gatsby 블로그 시작하기'\r\n   ---\r\n   ```\r\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}