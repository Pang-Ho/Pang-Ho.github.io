{"componentChunkName":"component---src-pages-index-jsx","path":"/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"배경  맥에서 구축된 프론트 프로젝트를 윈도우에서 켰을 때 보통 보이는 사진이다. 전체 화면에 빨갛게 오류로 나오니 정신 나갈 것 같다. 문제정의 CRLF와 LF가 무엇인가? 줄바꿈 방식의 차이라고 생각하면 된다. 윈도우는 , 맥, 리눅스는  으로 줄바꿈 처리를 진행한다. 그래서 윈도우는  +  ==  +  로 표시하는 것이고, 맥과 리눅스는  ==  으…","fields":{"slug":"/posts/react/crlf/"},"frontmatter":{"date":"April 06, 2025","title":"CRLF LF","tags":["CRLF","LF"],"emoji":"🚀","series":"React"},"rawMarkdownBody":"\n## 배경\n\n![CRLF error](./../../../images/react/crlf-error-screenshot.png)\n\n맥에서 구축된 프론트 프로젝트를 윈도우에서 켰을 때 보통 보이는 사진이다.\n\n전체 화면에 빨갛게 오류로 나오니 정신 나갈 것 같다.\n\n## 문제정의\n\n### CRLF와 LF가 무엇인가?\n\n줄바꿈 방식의 차이라고 생각하면 된다.\n\n윈도우는 `/r/n`, 맥, 리눅스는 `\\n` 으로 줄바꿈 처리를 진행한다.\n\n그래서 윈도우는 `CR` + `LF` == `\\r` + `\\n` 로 표시하는 것이고,\n\n맥과 리눅스는 `LF` == `\\n` 으로 표기하는 것이다.\n\n> 줄바꿈, line break, EOL(End Of Line)\n\n### 왜 이런 일이 일어났을까?\n\n나는 윈도우에서 이 프로젝트를 깃으로 받아 vs code로 켰다.\n\n그러나 이 프로젝트는 맥에서 만들어진 프로젝트였지만, 깃에 올렸을 때 `LF` 형식으로 올리지 않아서 생긴 이슈로 판단된다.\n\n### 저 에러는 어디서 내뱉는 걸까?\n\n이 에러는 `eslint`에서 내뱉는 것이다. 그래서 `.eslintrc.cjs` 파일을 열어 설정 중 `linebreak-style` 내용을 확인해보자.\n\n```\n{\n  'linebreak-style': ['error', 'unix']\n}\n```\n\n### CRLF와 LF 중 무엇을 선택해야하는가?\n\n가장 고민되는 사실일 것이다. 그러나 정답은 거의 정해져있다.\n\n1. `\\r\\n`과 `\\n`은 바이트 크기 차이가 있다.\n2. 리눅스나 맥에서 `\\r`은 줄바꿈 오류로 실행된다.\n3. `LF`는 표준이다.\n\n즉, LF를 사용하자.\n\n## 행동\n\n### CRLF를 LF로 변경하자\n\n- Prettier를 이용하여 전체 파일의 `CRLF`를 `LF`로 변경시킬 것이다.\n\n1. Prettier 설치 확인\n\n   ```sh\n   npx prettier -v\n   ```\n\n2. 버전이 출력되지 않는다면, Prettier 설치\n\n   ```sh\n    npx install --save-dev prettier\n   ```\n\n3. .prettierrc 파일 생성, LF 설정 적용\n\n   ```json\n   {\n     \"endOfLine\": \"lf\"\n   }\n   ```\n\n4. 설치한 Prettier를 이용하여 모든 파일을 적용한다.\n\n   ```sh\n   npx prettier --write .\n   ```\n\n![LF error](./../../../images/react/lf-screenshot.png)\n\n### 예방방법\n\n1. VSCode 설정\n\nVSCode 설정(crtl + ,)으로 들어가 eol을 검색한다.\n\n![VSCode EOL 설정](./../../../images/react/vscode-eol-screenshot.png)\n\n이곳에서 `\\n`으로 기본값을 변경한다.\n\n2. Git 커밋 설정\n\n```sh\n  git config --global core.autocrlf false\n  git config --global core.eol lf\n```\n\n## 결과\n\nCRLF와 LF의 차이를 알고 한꺼번에 처리하는 방법과 예방 방법을 알아보았다~\n"},{"excerpt":"리액트에서 URL 이동시 감지하여 원하는 로직을 넣어보자 🧪 테스트 환경 React v18 배경 요청사항으로 페이지 내에서 수정이 일어난 경우 URL을 이동하려고 할 시 confirm 창을 띄워 정말 이동하고 싶은건지 물어보는 기능이 필요하다고 한다. 리액트에서 제공해주는 방식이 없기 때문에 기능을 구현하고자 한다. 목표 리액트에서 URL을 이동할 수 있…","fields":{"slug":"/posts/react/react-prevent-navigate/"},"frontmatter":{"date":"April 02, 2025","title":"리액트에서 뒤로가기, 새로고침, 페이지 이동을 감지해보자","tags":["react"],"emoji":"🚀","series":"React"},"rawMarkdownBody":"\n# 리액트에서 URL 이동시 감지하여 원하는 로직을 넣어보자\n\n## 🧪 테스트 환경\n\n> React v18\n\n## 배경\n\n요청사항으로 페이지 내에서 수정이 일어난 경우 URL을 이동하려고 할 시 confirm 창을 띄워 정말 이동하고 싶은건지 물어보는 기능이 필요하다고 한다.\n\n리액트에서 제공해주는 방식이 없기 때문에 기능을 구현하고자 한다.\n\n## 목표\n\n리액트에서 URL을 이동할 수 있는 방법은 `Link 컴포넌트`, `useNavigate`, 뒤로가기, 새로고침, 앞으로가기가 있다.\n\n1. 제어가 안되는 `useNavigate` 훅과 `Link` 컴포넌트를 다른 방식으로 동작하도록 할 것\n2. 뒤로가기와 새로고침의 경우 브라우저의 이벤트를 이용하여 막을 것\n\n## 기능 추가\n\n1. 뒤로가기, 새로고침 이벤트 설정\n\n   뒤로가기와 새로고침을 막고자 하는 컴포넌트에 커스텀 훅을 넣어줘서 동작을 제어해보자.\n\n   ```javascript\n   //usePreventRefresh.ts\n   export const usePreventPageExit = () => {\n    const navigate = useNavigate();\n    const isModified =\n    /* 이곳에는 isModified를 전역으로 관리할 수 있는 방법을 이용한다.\n     * 상태값보단 불필요한 렌더링을 일으키지 않는 useRef 객체를 이용는 것을 추천합니다.\n     */\n\n    // 새로고침 이벤트 핸들러 함수\n    // 새로고침시 이벤트를 막는다면, 브라우저에서 지정해놓은 confirm 창이 뜬다.\n    const handleBeforeunload = (event) => {\n      if (isModified) {\n        event.preventDefault();\n        event.returnValue = '';\n      }\n    }\n\n    // 뒤로가기 이벤트 핸들러 함수\n    /* 방식\n     * 1. 첫 화면 렌더링시 window의 history 객체에 현재 주소로된 이력을 넣는다.\n     * 2. 뒤로가기 클릭시 이전 이력이 현재 주소이기 때문에 브라우저 화면이 다시\n          로드되지  않고, 현재 화면에 그대로 있는다.\n     * 3. window의 history 객체에 현재 주소로된 이력을 한 번 더 넣는다.\n     * 4. 사용자의 yes, no 클릭을 이용해 다음 행동을 결정짓는다.\n     * 4-1. yes 클릭\n        현재 히스토리에는 3번에서 넣은 이력으로 인해 2번 뒤로가도록 한다.\n       4-2. no 클릭\n        히스토리에 현재 주소 이력이 있어야하기 때문에 아무일도 일어나지 않는다.\n     */\n    const handlePopstate = () => {\n      if (isModified) {\n        history.pushState(null, '', location.href);\n        if (confirm('뒤로가시겠습니까? 작성된 내용은 저장이 되지 않습니다.')) {\n          navigate(-2);\n        }\n      } else {\n        navigate(-1);\n      }\n    }\n\n    useEffect(() => {\n      // 컴포넌트가 마운트되면 이벤트 생성 및 현재 주소 이력 추가\n      window.addEventListener('beforeunload', handleBeforeunload);\n      history.pushState(null, '', location.href);\n      window.addEventListener('popstate', handlePopstate);\n\n      return () => {\n        // 컴포넌트가 언마운트되면 이벤트를 제거한다.\n        window.removeEnventListener('beforeunload', handleBeforeunload);\n        window.removeEnventListener('popstate', handlePopstate);\n      }\n    }, [])\n   };\n   ```\n\n2. `useNavigate` 훅 커스텀\n\n`navigate('???')` 방식으로 리액트에서 페이지 이동을 시킨 경험이 있을 것 입니다. 위 처럼 페이지 이동시에 이벤트를 감지해서 막을 수 있지 않을까? 라는 생각을 했으면 바람직한 생각입니다. 그러나 `navigate` 함수가 실행이 되면, 중간에서 이벤트로 막을수가 없기 때문에 훅을 커스텀해서 사용해야 합니다. 저는 아래와 같이 사용했지만 절대로 정답은 아닙니다.\n\n```javascript\n  const useCustomNavigate = () => {\n    const navigate = useNavigate();\n    const isModified =\n    /* 이곳에는 isModified를 전역으로 관리할 수 있는 방법을 이용한다.\n     * 상태값보단 불필요한 렌더링을 일으키지 않는 useRef 객체를 이용는 것을 추천합니다.\n     */\n\n    const customNavigate = (to: To, options?: NavigateOptions, callback?: () => void) => {\n      if (isModified) {\n        if (confirm('이동하시겠습니까? 작성된 내용은 저장이 되지 않습니다.')) {\n          navigate(to, options);\n          isModified = false;\n          callback && callback();\n        } else {\n          navigate(to, options);\n          callback && callback();\n        }\n      }\n    }\n\n    return customNavigate;\n  }\n\n  export default useCustomNavigate();\n```\n\n3. 사용 방법\n\n   ```javascript\n    const BoardRegistPage = () => {\n      const navigate = useCustomNavigate();\n      const isModified =\n      /* 이곳에는 isModified를 전역으로 관리할 수 있는 방법을 이용한다.\n       * 상태값보단 불필요한 렌더링을 일으키지 않는 useRef 객체를 이용는 것을 추천합니다.\n       */\n\n      // 수정이 되었을 때 부터 이동 감지를 하고자 원한다면 이런 방식으로,\n      // 컴포넌트가 마운트 되자마자 막고 싶다면, useEffect를 이용\n      const handleChange = () => {\n        isModified = true;\n        ...\n      }\n\n      // isModified가 true면, navigate 함수에서 이동을 막는 로직이 실행된다.\n      const handleClick = () => {\n        navigate('/test');\n      }\n\n      return (\n        <>\n          {/* Link 컴포넌트는 to에 이동하지 않도록 #을 넣어주고, 이동 방식은 onClick을 이용하여 이동을 막도록 한다.*/}\n          <Link\n            to=\"#\"\n            onClick={handleClick}\n          >이동</Link>\n\n          ...\n        </>\n      )\n    }\n   ```\n\n   4. 전역으로 사용할 변수 `isModified`\n\n   `isModified` 는 전역으로 사용할 변수를 이용한다.\n\n   1. 컴포넌트 밖에서 선언한 let 변수 (권장안함)\n   2. 상태관리 라이브러리 (zustand, Redux 등) (상태값으로 선언시 불필요한 리렌더링 유발)\n   3. `useRef` 객체 (권장)\n\n   위 내용을 기반으로 `Context` 에 `useRef` 객체로 선언된 `isModified`를 불러와서 사용하자.\n\n   이 경우 불필요한 리렌더링을 안하기 때문에 편리하게 사용할 수 있고, 어디서든 불러와서 사용할 수 있다.\n"},{"excerpt":"🧪 테스트 환경 아래 명령어를 통해  템플릿을 이용하는 사람의 경우거나 블로그에 댓글을 를 통해 만들고 싶은 경우 참고만 하면 된다. 🍳 giscus가 무엇인가? giscus는 의 을 통해 댓글 기능을 만들어주는 편리한 라이브러리입니다. 개발자는 에서  기능을 열어두고, giscus 홈페이지에서  주소와 여러 설정을 추가하면 giscus 정보를 받을 수 …","fields":{"slug":"/posts/how-to/giscus/"},"frontmatter":{"date":"March 13, 2025","title":"giscus 시작하기","tags":["gatsby"],"emoji":"✋","series":"gatsby"},"rawMarkdownBody":"\n## 🧪 테스트 환경\n\n아래 명령어를 통해 `gatsby-starter-rundevelrun` 템플릿을 이용하는 사람의 경우거나 블로그에 댓글을 `github`를 통해 만들고 싶은 경우 참고만 하면 된다.\n\n```shell\ngatsby new your-blog-name https://github.com/rundevelrun/gatsby-starter-rundevelrun.git\n```\n\n## 🍳 giscus가 무엇인가?\n\ngiscus는 `github repository`의 `Discussion`을 통해 댓글 기능을 만들어주는 편리한 라이브러리입니다.\n\n개발자는 `github repository`에서 `Discussion` 기능을 열어두고, giscus 홈페이지에서 `github repository` 주소와 여러 설정을 추가하면 giscus 정보를 받을 수 있습니다.\n\n## ☝ giscus 설정 방법\n\n1. 댓글 데이터를 담아둘 `repository`에 접속한다.\n   - `public repository`인지 확인한다.\n   - [giscus 설치 페이지](https://github.com/apps/giscus) 접속하여 giscus를 설치한다.\n   - `repository settings`로 들어가서 `Features`에 있는 `Discussions` 체크박스에 체크한다.\n2. [giscus 홈페이지](https://giscus.app/ko) 접속하여 설정한다.\n   - 저장소 명을 입력한다.\n   - Discussions 연결 방법을 선택한다.\n   - Discuussion 카테고리를 선택한다. (Announcements를 권장합니다.)\n   - 원하는 테마와 기능을 설정하고, `giscus script`를 복사한다.\n   ```javascript\n   //예시\n   <script\n     src=\"https://giscus.app/client.js\"\n     data-repo=\"[ENTER REPO HERE]\"\n     data-repo-id=\"[ENTER REPO ID HERE]\"\n     data-category=\"[ENTER CATEGORY NAME HERE]\"\n     data-category-id=\"[ENTER CATEGORY ID HERE]\"\n     data-mapping=\"pathname\"\n     data-strict=\"0\"\n     data-reactions-enabled=\"1\"\n     data-emit-metadata=\"0\"\n     data-input-position=\"bottom\"\n     data-theme=\"preferred_color_scheme\"\n     data-lang=\"ko\"\n     crossorigin=\"anonymous\"\n     async\n   ></script>\n   ```\n\n## ✌ 개인 블로그에서 giscus 컴포넌트 만들어서 사용하기\n\n1. giscus 라이브러리 설치\n\n   ```shell\n   npm i giscus\n   ```\n\n2. 컴포넌트 생성\n\n   `giscus script`에서 받은 데이터를 컴포넌트에 넣어서 사용하면 완성!\n\n   ```javascript\n   import Giscus from '@giscus/react';\n\n   export default function MyApp() {\n     return (\n       <Giscus\n         id=\"comments\"\n         repo=\"[ENTER REPO HERE]\"\n         repoId=\"[ENTER REPO ID HERE]\"\n         category=\"[ENTER CATEGORY NAME HERE]\"\n         categoryId=\"[ENTER CATEGORY ID HERE]\"\n         mapping=\"pathname\"\n         term=\"Welcome to @giscus/react component!\"\n         reactionsEnabled=\"1\"\n         emitMetadata=\"0\"\n         inputPosition=\"bottom\"\n         theme=\"light\"\n         lang=\"ko\"\n         loading=\"lazy\"\n       />\n     );\n   }\n   ```\n\n   > [giscus Github 주소](https://github.com/giscus/giscus-component) 참고하였습니다.\n\n## ✌ rundevelrun/gatsby-starter-rundevelrun 템플릿 전용 설정\n\n`blog-config.js`의 내용 수정\n\n```javascript\nmodule.exports = {\n   ...\n   links: {\n      ...\n   },\n   giscus: {\n      repo=\"[ENTER REPO HERE]\"\n      repoId=\"[ENTER REPO ID HERE]\"\n      category=\"[ENTER CATEGORY NAME HERE]\"\n      categoryId=\"[ENTER CATEGORY ID HERE]\"\n      mapping=\"pathname\"\n      strict=\"0\"\n      reactionsEnabled: '1',\n      inputPosition=\"bottom\"\n      lang: 'ko',\n   },\n   adsense: {\n      ...\n   }\n}\n```\n\n## 👍 댓글 창 확인\n\n![giscus 댓글 스크린샷](./../../../images/how-to/giscus-screenshot.png)\n"},{"excerpt":"리액트 폴더구조 회사에서 처음 리액트 프로젝트를 시작할 때 가장 이해가 안되던 부분이 폴더구조였다.\n당시  폴더 아래에는 메뉴 단위로 가져갔고, 공통 컴포넌트는  아래에 파일 단위로만 들어가 있었다.\n또한 와 의 차이를 몰랐었다. 중간에 프로젝트를 투입하게 되면서 내가 보는 페이지가 어떤 파일인지 유추가 안되고, 파일을 어디에 둬야할지 고민이 되었다. 다…","fields":{"slug":"/posts/react/react-folder/"},"frontmatter":{"date":"March 11, 2025","title":"React Folder","tags":["react"],"emoji":"🚀","series":"React"},"rawMarkdownBody":"\n# 리액트 폴더구조\n\n회사에서 처음 리액트 프로젝트를 시작할 때 가장 이해가 안되던 부분이 폴더구조였다.\n당시 `src` 폴더 아래에는 메뉴 단위로 가져갔고, 공통 컴포넌트는 `components` 아래에 파일 단위로만 들어가 있었다.\n또한 `public/assets`와 `src/assets`의 차이를 몰랐었다.\n\n중간에 프로젝트를 투입하게 되면서 내가 보는 페이지가 어떤 파일인지 유추가 안되고, 파일을 어디에 둬야할지 고민이 되었다.\n\n다른 사람들은 어떤 폴더구조를 쓸까? 에 대한 내용과 내가 사용하는 폴더 구조를 소개하려고 한다.\n\n> 기본적으로 폴더구조는 프로젝트 상황과 사용하는 라이브러리, 디자인 패턴에 맞게 수정하는게 맞다고 생각한다.\n\n## create-react-app 폴더구조\n\n```\nmy-app/\n├── node_modules/       # 프로젝트에 필요한 모든 의존성이 저장되는 폴더\n├── public/             # 정적 파일이 저장되는 폴더\n│   ├── favicon.ico     # 브라우저 탭에 표시되는 아이콘\n│   ├── index.html      # React 앱이 로드되는 기본 HTML 파일\n│   ├── logo192.png     # 기본 제공 로고 이미지 (192x192 크기)\n│   ├── logo512.png     # 기본 제공 로고 이미지 (512x512 크기)\n│   ├── manifest.json   # PWA 관련 설정 파일\n│   ├── robots.txt      # 검색 엔진 크롤러 관련 설정 파일\n│   └── ...\n├── src/                # 애플리케이션의 주요 소스 코드가 들어가는 폴더\n│   ├── App.css         # `App` 컴포넌트의 스타일 정의\n│   ├── App.js          # 주요 애플리케이션 컴포넌트\n│   ├── App.test.js     # `App` 컴포넌트의 테스트 파일\n│   ├── index.css       # 전역 스타일 정의\n│   ├── index.js        # 애플리케이션의 진입점 파일\n│   ├── logo.svg        # 기본 제공 React 로고 (SVG 형식)\n│   ├── reportWebVitals.js # 성능 측정 관련 코드\n│   ├── setupTests.js   # 테스트 설정 파일 (Jest)\n│   └── ...\n├── .gitignore          # Git에서 무시할 파일 목록\n├── package.json        # 프로젝트 및 의존성 설정 파일\n├── README.md           # 프로젝트 설명 파일\n├── yarn.lock / package-lock.json  # 의존성 고정 파일\n└── ...\n```\n\n- 리액트를 처음 시작할 때 바로 볼 수 있는 폴더구조이다.\n  리액트를 처음 하는 사람한테는 src 내부 구조가 없어 폴더를 어떻게 만들지 고민이 된다.\n\n### src 폴더 구체화\n\n```\nsrc/\n├── components/       # 재사용 가능한 UI 컴포넌트\n├── pages/            # 주요 페이지 구성 요소\n├── hooks/            # 사용자 정의 훅\n├── services/         # API 호출 및 비즈니스 로직\n├── types/            # 타입\n├── utils/            # 유틸리티 함수\n├── context/          # React Context API 관련 코드\n└── assets/           # 이미지, 폰트, 아이콘 등 정적 리소스\n```\n\n- Chat GPT는 `src` 구조를 위 처럼 확장하는 것을 추천한다. 페이지 단위로 파일을 만들고, 재사용이 가능한 컴포넌트는 따로 관리하며\n  커스텀 훅도 따로 관리한다. 실제로 파일들을 넣어보자\n\n```\nsrc/\n├── components/       # 재사용 가능한 UI 컴포넌트\n│\t\t└── board-header.tsx\n├── pages/            # 주요 페이지 구성 요소\n│       └── board-page.tsx\n├── hooks/            # 사용자 정의 훅\n│\t\t└── use-board.ts\n├── services/         # API 호출 및 비즈니스 로직\n│\t\t└── board-api.ts\n├── types/            # 타입\n│\t\t└── board.ts\n├── utils/            # 유틸리티 함수\n│\t\t└── date-util.ts\n├── context/          # React Context API 관련 코드\n├── assets/           # 이미지, 폰트, 아이콘 등 정적 리소스\n│\t\t└── image1.png\n...\n```\n\n- 첫 프로젝트 때 이러한 구조가 되었었다. 게시판을 위 처럼 개발했을 때 수정이 필요한 경우\n  광범위하게 흩어진 코드를 찾으러 다녀야해서 너무 힘들었다.\n\n> 그래서 생각한 것은\n>\n> 1. URL 경로와 페이지 컴포넌트는 보통 1 : 1 이니까 경로에 맞게 폴더 구조를 만들기\n> 2. 특성이 같고, 수정사항이 많은 파일의 경우는 같은 곳에 넣어두자\n\n## 내가 사용하던 폴더 구조\n\n- 아래 조건들에 맞춰 `pages` 폴더를 좀더 구체화 하였다.\n  - 프로젝트 규모가 작다\n  - 라우팅 되는 URL 경로 구조와 `pages` 폴더 구조가 같도록 한다\n    - 폴더로 라우팅 구조 파악 가능\n  - 중요 로직은 커스텀 훅에서 관리한다\n    - UI와 로직 분리\n\n```\nsrc/\n├── components/                     # 재사용 가능한 UI 컴포넌트\n├── pages/                          # 주요 페이지 구성 요소\n│       └── board/                  # URL 경로\n│            ├── components/        # 종속된 UI 컴포넌트\n│            │    ├── hooks/        # 종속된 커스텀 훅\n│\t\t         │    │    └── use-board-header.ts\n│\t\t         │    │\n│\t\t         │    └── board-header.tsx\n│            ├── hooks/             # 종속된 커스텀 훅\n│\t\t         │    └── use-board.ts\n│            ├── schema/            # hook-form 스키마\n│\t\t         │    └── board-schema.ts\n│            ├── api/               # API 호출\n│\t\t         │    └── board-api.ts\n│            ├── models/            # 타입\n│\t\t         │    └── board.ts\n│            └── board-page.tsx\n│\n├── hooks/            # 전역으로 사용하는 사용자 정의 훅\n├── apis/             # 전역으로 사용하는 API 호출\n├── models/           # 전역으로 사용하는 타입\n├── utils/            # 유틸리티 함수\n├── assets/           # 이미지, 폰트, 아이콘 등 정적 리소스\n├── routers/          # 라우팅 관련 컴포넌트\n├── stores/           # 상태관리 라이브러리 상태\n├── App.tsx           # 최상위 컴포넌트\n└──\n```\n\n`board` 경로에는 이제 한 곳에서 소스를 한 눈에 확인할 수 있고, 관리 포인트도 좁아졌다.\n프로젝트를 혼자하는 것도 아니고, 새로 들어오는 개발자에게 폴더 구조를 몇 시간동안 강의할 것이 아니라면\n이해가 가는 선에서 구조를 만들어주는 방향은 정말 좋은 것 같다.\n\n또한 커스텀 훅 패턴으로 훅에 로직을 모두 넣어두고 컴포넌트에서 불러오는 방식이 유지보수 방면에서 좋다고 느꼈다.\nUI 컴포넌트에서 UI 소스 부분에 서비스 로직이 들어있는 경우 소스 보기가 불편한 경우가 많았다..\n\n## 유명한 FSD\n\n위 구조를 보면 `게시판`이라는 특징을 가진 기능을 `board` 폴더로 묶은 모습을 볼 수 있다.\n같은 특징을 가진 소스는 한 곳으로 모아두자 라는 느낌으로 묶은 것인데, `feature`와 관련된 유명한 아키텍처 방법론으로 `FSD`가 있다.\n물론 내가 사용하던 폴더 구조와는 많이 다르게 생겼다.\n`layer`로 둬서 같은 엄격하게 폴더에 들어갈 소스 위치를 구분하고 `feature`에서 기능을 묶는 방법론이다.\n\n![FSD Scheme.png](FSD Scheme.png)\n\n위 사진만으로 이해가 되지않지만, FSD 홈페이지를 가보면, 예제와 마이그레이션 방법도 친절히 나와있다.\n\n[FSD 마이그레이션 방법](https://feature-sliced.design/docs/guides/migration/from-v1) 그 중에 `layer` 내용만 가져와보겠다.\n\n- FSD Layer\n  - /app — application initialization layer\n    - Previous versions: app, core, init, src/index (and this happens)\n  - /processes — business process layer\n    - Previous versions: processes, flows, workflows\n  - /pages — application page layer\n    - Previous versions: pages, screens, views, layouts, components, containers\n  - /features — functionality parts layer\n    - Previous versions: features, components, containers\n  - /entities — business entity layer\n    - Previous versions: entities, models, shared\n  - /shared — layer of reused infrastructure code 🔥\n    - Previous versions: shared, common, lib\n\n여기서 크게 `app / pages / features` 만 봐도 좋다.\n\n```\nsrc/\n├── app\n│       ├── layout/\n│       ├── providers/\n│       ├── routers/\n│       └── App.tsx\n├── pages\n│       └── board/\n│            └── board-page.tsx\n├── features\n│       └── board/\n│            └── ui/\n│\t\t          └── board-header.tsx\n├── entities\n│       └── board/\n│\t\t     └── types.ts\n├── shared\n│       └── api/\n│            └── board/\n│\t\t          └── board-api.ts\n│       └── assets/\n│       └── lib/\n└──\n```\n\n크게 내용을 넣진 않았지만, `app` > `pages` > `features` > `entities` > `shared` 형식으로 층을 나누어서 자기보다 아래에 있는 층만\n참조해서 가져오는 방식이다.\n복잡하지만 상당히 큰 프로젝트에는 모든 기능이 나눠져있어 관리하는 부분에선 좋을 것이다.\n\n## MIT 리액트 아키텍처\n\n[MIT 리액트 아키텍처](https://github.com/alan2207/bulletproof-react/)\n\n리액트 아키텍처 구조를 가이드처럼 만들어둔 레포가 있다. `Star 29k` 가 넘어간 유명한 레포며, `feature`를 기준으로 폴더를 설계하였다.\n`nextjs 앱`, `nextjs 웹`, `react-vite` 세개의 구조를 보여준다.\n\n> bulletproof 는 안정적인 코드를 뜻한다.\n\n```\nsrc/\n├── features\n│       └── comments/\n│            └── api/\n│\t\t         └── components/\n└──\n```\n\n`feature` 폴더 하나를 기준으로 보면, 내가 사용하는 폴더구조와 비슷하게 한 곳에서 관련된 소스들을 관리한다.\n하지만 `FSD`와 비슷하게 `app` 폴더에서 어플리케이션 구조를 만든다. `pages` 폴더 없이 `app`폴더에서 모두 관리한다.\n\n```\nsrc/features/awesome-feature\n|\n+-- api         # exported API request declarations and api hooks related to a specific feature\n|\n+-- assets      # assets folder can contain all the static files for a specific feature\n|\n+-- components  # components scoped to a specific feature\n|\n+-- hooks       # hooks scoped to a specific feature\n|\n+-- stores      # state stores for a specific feature\n|\n+-- types       # typescript types used within the feature\n|\n+-- utils       # utility functions for a specific feature\n```\n\n## 정리\n\n`FSD`, `bulletproof-react repository`를 구경해봤다. `feature` 폴더에 기능 기준으로 컴포넌트를 만들고, 필요한 `api` 호출이나 종속된 컴포넌트의 경우 같은 공간에 만들어 소스 확인할 때 이리저리 움직이지 않게 만드는 모습을 보인다. `feature` 방식을 이용해볼까 생각중이다. 물론 마이그레이션까지 하면서 진행할 생각은 없다.\n\n프로젝트가 진행되면서 공통적으로 만들어야하는 기능이 많아지는 경우 `src/component` 폴더가 매우 커졌던 경험이 있다. 즐겨찾기가 되는 버튼형 아이콘을 만들 때 기능에 치중한 컴포넌트이니까 `src/component/feature` 폴더를 만들거나, `src/component/feature` 폴더를 만들어서 한 곳에 만들고, `src/component/ui` 폴더에는 기능이 없는 컴포넌트는 어떤가 싶기도 하다.\n\n> 운영하는 시스템에서 조금 신경쓰일정도로 느린 화면들이 있는데, `SSR`을 사용하면 조금 나아질까 싶어 Nextjs를 공부하고있다.\n>\n> 사용하던 폴더구조를 보니 Nextjs의 페이지 라우팅 구조와 비슷한 모습을 보여 놀랐다.\n"},{"excerpt":"🧪 테스트 환경 NodeJS v22.13.0 \nyarn 1.22.22 🛠️ 환경 설정 NodeJS↗ 설치 yarn 설치 gatsby-cli 설치 Gatsby 블로그 생성 🚀 개발 환경 구동 아래 과정을 거친 후 으로 접속 의존성 패키지 설치 구동 구동 방법은 사용하는 Gatsby 템플릿마다  에 작성된 yarn 명령어는 다르겠지만, 대부분 동일하게  명령어…","fields":{"slug":"/posts/how-to/gatsby/"},"frontmatter":{"date":"January 18, 2025","title":"Gatsby 블로그 시작하기","tags":["gatsby"],"emoji":"✋","series":"gatsby"},"rawMarkdownBody":"\n## 🧪 테스트 환경\n\n> NodeJS v22.13.0 <br/>\n> yarn 1.22.22\n\n## 🛠️ 환경 설정\n\n1. [NodeJS↗](https://nodejs.org/ko/download) 설치\n2. yarn 설치\n   ```shell\n   npm install -g yarn\n   ```\n3. gatsby-cli 설치\n   ```shell\n   yarn global add gatsby-cli\n   ```\n4. Gatsby 블로그 생성\n\n   ```shell\n   gatsby new [your-blog-name] [사용하고 싶은 Gatsby 템플릿]\n\n   예시 : gatsby new your-blog-name https://github.com/rundevelrun/gatsby-starter-rundevelrun.git\n   ```\n\n## 🚀 개발 환경 구동\n\n아래 과정을 거친 후 `http://localhost:8000`으로 접속\n\n1. 의존성 패키지 설치\n\n   ```shell\n   cd your-blog-name\n   yarn install\n   ```\n\n2. 구동\n\n   구동 방법은 사용하는 Gatsby 템플릿마다 `package.json` 에 작성된 yarn 명령어는 다르겠지만, 대부분 동일하게 `gatsby develop` 명령어를 사용하시면 됩니다.\n\n   **이후 내용부터는 `https://github.com/rundevelrun/gatsby-starter-rundevelrun.git` 템플릿을 기준으로 설명서가 작성되었습니다.**\n\n   ```shell\n   yarn develop\n   ```\n\n## ☺️ 사용자화\n\n`blog-config.js`의 내용 수정\n\n```javascript\nmodule.exports = {\n  title: \"YOUR:BLOG:NAME\",    // SEO Blog title\n  headerTitle: \"YOUR:<em style='color:#ed6c02'>BLOG</em>:NAME\", // Logo 1\n  headerSubTitle: \"<em style='color:#ed6c02'>YOUR</em>:BLOG:<em style='color:#ed6c02'>NAME</em>\", // Logo 2\n  copyright: \"©YOUR:BLOG:NAME\", // copyright in footer\n  author: \"YOUR:NAME\",  // Your Name\n  siteUrl: \"https://6developer.com/\", // Your Site URL\n  description: \"Hi, Nice to meet you !\",  // Blog description\n  links: {\n    github: \"https://github.com/rundevelrun\",\n    ...\n  },\n  giscus: {\n    ...\n  },\n  adsense: {\n    ...\n  }\n}\n```\n\n## 📝 게시글 작성\n\n1. `contents/posts` 폴더에 게시글 파일 생성 (두가지 방법)\n   1. pathname으로 사용할 이름의 폴더를 만들고 하위에 'index.md'를 생성\n   2. pathname으로 사용할 이름으로 `*.md` 파일 생성\n2. frontmatter 작성\n   ```yaml\n   ---\n   emoji: '🚀'\n   title: '어떻게 시작할까요?'\n   date: 2025-01-19 13:53:00\n   update: 2025-01-19 13:53:00\n   tags:\n     - rundevelrun\n     - howto\n   series: 'Gatsby 블로그 시작하기'\n   ---\n   ```\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}